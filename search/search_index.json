{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyBWE: Python tools for Bandwidth Extrapolation of planetary radar signals Resolution enhancement of radar signals with the super-resolution technique named \"Bandwidth Extrapolation\" (BWE). Introduction to PyBWE The Bandwidth Extrapolation technique Range resolution enhancement is one of the main challenges in radar signal processing. It is limited by the frequency bandwidth of the instrument: the larger is the bandwidth, the better is the resolution. Classic Fourier transform techniques are efficient and robust for spectral estimation, but in practical applications the output resolution is limited. For this reason parametric spectral estimation techniques have been introduced (see Kay and Marple, 1981). Based on a signal model, assuming deterministic properties of the signal, the output of such techniques yields a better resolution. However, parametric techniques are less robust than classic Fourier transform ones, in particular in the presence of noise or distortions. The Bandwidth Extrapolation technique ( BWE ) is a compromise between a classic Fourier transform and a parametric spectral estimation technique (Cuomo, 1992). A parametric model is fitted to the signal's spectrum, this model is then used to extrapolate this spectrum forward and backward, and the spectrum is eventually Fourier transformed using IFFT. The extrapolation factor is equal to the resolution enhancement, and can be up to 3 in practical cases. In the regular BWE, the signal is modelled by an autoregressive (AR) model, using the Burg algorithm (Burg, 1967). Several improvements to the BWE have been proposed: the Polarimetric BWE ( PBWE ) using the correlation between several polarimetric radar channels for an improved extrapolation (Suwa and Iwamoto, 2003,2007), or the State-Space BWE ( SSBWE ) using a State-Space model to account for noise and exponential distortions in the signal (Piou, 1999). Also, the BWE can be used to fill gap between two spectra of multiband radars (Moore, 1997). This process is known as Bandwidth Interpolation ( BWI ). Recent application to planetary radar sounders If the BWE can be applied to any radar signals, it has been extensively applied to planetary radar sounders. Radar sounders unlocked a 3 rd dimension in planetary studies, allowing scientists to discover the widely unknown subsurface of the Moon, Mars, Titan and soon Venus and Jupiter's moons. The development of space instruments being very constrained, the BWE is a mean to get as much information on the subsurface structure and composition from a given radar instrument. Here is a non-exhaustive list of successful BWE applications in planetary science: The 1 st bathymetry of a Titan sea using Cassini radar data (Mastrogiuseppe et al., 2014) The improvement of the stratigraphic analysis of Martian polar ice sheets using SHARAD (MRO) radar sounder data (Raguso et al., 2018) The improvement of the WISDOM (ExoMars) Ground Penetrating Radar soundings in preparation of the Rosalind Franklin rover mission (Oudart et al., 2021) The improvement of the MARSIS (Mars Express) radar sounder resolution by a factor of 6 using both BWE and BWI (Gambacorta et al., 2022) The BWE helped the estimation of attenuations in the Martian subsurface with the RIMFAX (Mars 2020) Ground Penetrating Radar data (Eide et al., 2022) With the arrival of WISDOM (ExoMars) on Mars in 2028, as well as new radar sounders selected for the exploration of Venus (EnVision mission) and Jupiter's icy moons (Juice and Europa Clipper missions) in the 2030s, we expect the BWE techniques to be useful for future planetary science studies. Hence the publication of this Python library, intented to help the planetary science community use the BWE on any radar sounder data.","title":"Home"},{"location":"#pybwe-python-tools-for-bandwidth-extrapolation-of-planetary-radar-signals","text":"Resolution enhancement of radar signals with the super-resolution technique named \"Bandwidth Extrapolation\" (BWE).","title":"PyBWE: Python tools for Bandwidth Extrapolation of planetary radar signals"},{"location":"#introduction-to-pybwe","text":"","title":"Introduction to PyBWE"},{"location":"#the-bandwidth-extrapolation-technique","text":"Range resolution enhancement is one of the main challenges in radar signal processing. It is limited by the frequency bandwidth of the instrument: the larger is the bandwidth, the better is the resolution. Classic Fourier transform techniques are efficient and robust for spectral estimation, but in practical applications the output resolution is limited. For this reason parametric spectral estimation techniques have been introduced (see Kay and Marple, 1981). Based on a signal model, assuming deterministic properties of the signal, the output of such techniques yields a better resolution. However, parametric techniques are less robust than classic Fourier transform ones, in particular in the presence of noise or distortions. The Bandwidth Extrapolation technique ( BWE ) is a compromise between a classic Fourier transform and a parametric spectral estimation technique (Cuomo, 1992). A parametric model is fitted to the signal's spectrum, this model is then used to extrapolate this spectrum forward and backward, and the spectrum is eventually Fourier transformed using IFFT. The extrapolation factor is equal to the resolution enhancement, and can be up to 3 in practical cases. In the regular BWE, the signal is modelled by an autoregressive (AR) model, using the Burg algorithm (Burg, 1967). Several improvements to the BWE have been proposed: the Polarimetric BWE ( PBWE ) using the correlation between several polarimetric radar channels for an improved extrapolation (Suwa and Iwamoto, 2003,2007), or the State-Space BWE ( SSBWE ) using a State-Space model to account for noise and exponential distortions in the signal (Piou, 1999). Also, the BWE can be used to fill gap between two spectra of multiband radars (Moore, 1997). This process is known as Bandwidth Interpolation ( BWI ).","title":"The Bandwidth Extrapolation technique"},{"location":"#recent-application-to-planetary-radar-sounders","text":"If the BWE can be applied to any radar signals, it has been extensively applied to planetary radar sounders. Radar sounders unlocked a 3 rd dimension in planetary studies, allowing scientists to discover the widely unknown subsurface of the Moon, Mars, Titan and soon Venus and Jupiter's moons. The development of space instruments being very constrained, the BWE is a mean to get as much information on the subsurface structure and composition from a given radar instrument. Here is a non-exhaustive list of successful BWE applications in planetary science: The 1 st bathymetry of a Titan sea using Cassini radar data (Mastrogiuseppe et al., 2014) The improvement of the stratigraphic analysis of Martian polar ice sheets using SHARAD (MRO) radar sounder data (Raguso et al., 2018) The improvement of the WISDOM (ExoMars) Ground Penetrating Radar soundings in preparation of the Rosalind Franklin rover mission (Oudart et al., 2021) The improvement of the MARSIS (Mars Express) radar sounder resolution by a factor of 6 using both BWE and BWI (Gambacorta et al., 2022) The BWE helped the estimation of attenuations in the Martian subsurface with the RIMFAX (Mars 2020) Ground Penetrating Radar data (Eide et al., 2022) With the arrival of WISDOM (ExoMars) on Mars in 2028, as well as new radar sounders selected for the exploration of Venus (EnVision mission) and Jupiter's icy moons (Juice and Europa Clipper missions) in the 2030s, we expect the BWE techniques to be useful for future planetary science studies. Hence the publication of this Python library, intented to help the planetary science community use the BWE on any radar sounder data.","title":"Recent application to planetary radar sounders"},{"location":"PyBWE/","text":"PyBWE package Description The PyBWE package is the \"plain vanilla\" package of this library. It allows you to apply the classic Bandwidth Extrapolation (BWE) technique as defined by Cuomo (1992) to any radar spectrum. The BWE is a super-resolution technique, as it yields a better range resolution in time-domain than classic spectral estimation techniques (FFT). The BWE works this way: The input is the frequency-domain spectrum of the radar's reponse signal from a series of targets. In this situation, the signal should in theory be a sum of complex sine-waves. An autoregressive (AR) model is fitted to this spectrum, using the Burg or the Modified Covariance algorithm. The order of the model is a user-defined parameter. This model is used to extrapolate the spectrum forward and backward. The extrapolating factor is a user-defined parameter. The super-resolved time-domain sounding is obtained by IFFT. Zero-padding can be used for time-domain interpolation (this process is purely aesthetic). The spectrum's extrapolation factor is equal to the resolution enhancement factor after IFFT. The PyBWE package contains the PyBWE.BWE function, allowing you to apply the BWE directly to a given radar spectrum and get a super-resolved sounding. This function calls several other functions from the package, that you can call independently if needed: PyBWE.burg: fits an AR model to a spectrum, using the Burg algorithm. PyBWE.mcov: fits an AR model to a spectrum, using the Modified Covariance algorithm. PyBWE.ar_extrapolation: extrapolates forward, backward or both a spectrum, given an AR model. Importation Once the library is installed, the PyBWE package can simply be imported: import PyBWE Recommendations The order of the AR model In theory, the ideal order of an AR model depends on the number of complex sine-waves composing the spectrum. However, in practical cases, a higher order is required to obtain good results in presence of noise. For the BWE, Cuomo (1992) recommends an order equal to \u2153 of the number of samples in the spectrum. The extrapolation factor In theory, a sum of sine-wave can be extrapolated infinitely. However, in practical cases, errors accumulate with the extrapolation. For the BWE, Cuomo (1992) recommends an extrapolation factor of maximum 3. The effect of side-lobes In the case of a radar signal spectrum obtained by FFT, 2 effects must be mitigated before BWE: If a window was applied to the signal, it must be inverted. The application of the FFT generates side-lobes effects on the borders of the spectrum. For this reason, Cuomo (1992) recommends to remove 5% of frequencies on each side of a spectrum before BWE. In the case of a radar measuring only the real-part of a frequency spectrum, the imaginary part can be reconstructed by Hilbert transform. The FFT being part of Hilbert transform implementations, errors can also be expected on the border of the spectrum. We thus also recommend to cut 5% of samples on each side of a spectrum in this case. The PyBWE.BWE function allows you to remove 5% of samples on each side of a spectrum before BWE. The effect of distortions The BWE technique is based on the assumption that the spectrum of a radar response signal from targets is a sum of complex sine-waves. In many practical applications, a radar response signal can differ from this model, due to various distortion effects. Such distortions can make the application of the direct application of the BWE impossible. We thus recommend to correct distortions prior to a BWE application. Different solutions are possible for different sources of distortion: Effect of the antennas gain: No antenna can transmit all frequencies with the same gain. This will cause distortions of sine-waves in a radar spectrum. You can try to compensate for this effect with a calibration radar measurement on a \"perfect reflector\" (a metallic sphere or a large metallic plate). From the spectrum of the echo from such target, the antennas gain can be determined, and inverted in all other radar measurements. This process is sometimes called \"whitening\" and is described in Oudart et al. (2021). As different temperatures can lead to significantly different amplitudes over a radar's bandwidth, for a successful whitening process we recommend to apply first a temperature correction (as the one described in Herv\u00e9 et al. (2020)). Effect of the ionosphere: The ionosphere of any planet has a frequency-dependent attenuation effect on electromagnetic waves. This will cause distortions of sine-waves in a radar spectrum. This effect can be compensated using a ionospheric model. For instance Gambacorta et al. (2022) used a ionospheric Gamma model before applying the BWE to MARSIS (Mars Express) soundings. Effect of subsurface attenuations: When a radar signal is transmitted through a sub-surface, it is affected by different frequency-dependent attenuations (absorption, scattering...). It can thus be expected that deeper echoes in a high-loss subsurface will not be correctly reconstructed by BWE. We recommend to use the PySSBWE package, as the SSBWE (State-Space Bandwidth Extrapolation) technique accounts for such attenuations. The effect of noise The presence of noise in a signal impact the quality of the AR model determined by the Burg algorithm. For this reason, a high level of noise will impact the BWE results (echoes amplitudes and time-delays), as demonstrated in Oudart et al. (2021). To mitigate the effect of noise, we recommend to use a more complex model, like the ones provided in PyPBWE and PySSBWE packages. Electromagnetic interferences EM interferences can cause peaks in the measured radar spectrum. Such peaks will impair the AR modelling of the signal. The effect can be mitigated by detecting outliers in the spectrum, and then replacing them by interpolation, as proposed by Raguso et al. (2018). Cross-talk If the emission and reception antennas / channels are not the same, a cross-talk phenomenon can generate unwanted signals in the radar response. It is recommended to remove such effects prior to the application of the BWE. This can for instance be done by subtracting a \"free-space\" (without any targets) calibration signal to any radar response. Functions PyBWE.ar_extrapolation(x,ar_coeff,Nextra,extra_mode='both') The PyBWE.ar_extrapolation function extrapolates a spectrum given its AR model, forward, backward or both. Inputs: x: complex 1D array containing the spectrum to be extrapolated. ar_coeff: complex 1D array containing the coefficients of the spectrum's AR model. Nextra: integer number of samples to be extrapolated forward, backward or both. extra_mode: (optional) string containing the extrapolation mode, \"forward\"/\"backward\"/\"both\". Outputs: x_extra: complex 1D array containing the extrapolated spectrum. x_forward: complex 1D array containing the forward extrapolation, empty if in \"backward\" mode. x_backward: complex 1D array containing the backward extrapolation, empty if in \"forward\" mode. PyBWE.burg(x,p) The PyBWE.burg function fits an AR model to a spectrum, using the Burg algorithm. Inputs: x: complex 1D array containing the spectrum to be modelled. p: integer order of the AR model. Outputs: a: complex 1D array containing the AR model coefficients. e: float estimated white-noise variance. rc: complex 1D array containing the Burg algorithm's reflection coefficients. PyBWE.mcov(x,p) The PyBWE.mcov function fits an AR model to a spectrum, using the Modified Covariance algorithm. Inputs: x: complex 1D array containing the spectrum to be modelled. p: integer order of the AR model. Outputs: a: complex 1D array containing the AR model coefficients. e: float estimated white-noise variance. PyBWE.BWE(spec,df,extra_factor,model_order,zp_factor,side_cut=True,method='burg') The PyBWE.BWE function applies the Bandwidth Extrapolation to a radar signal's spectrum. Inputs: spec: complex 1D array containing the spectrum to which the BWE will be applied. df: float frequency step corresponding to spec [Hz]. extra_factor: float factor between the extrapolated and the original spectrum's bandwidths. model_order: float order of the AR model for extrapolation, expressed as a ratio of the original spectrum's bandwidth. zp_factor: float factor between the zero-padded and original spectrum's bandwidth. side_cut: (optional) boolean , 5% of samples are cut on each side of the spectrum if True. method: (optional) string name of the method to determine the AR model ('burg' for Burg, or 'mcov' for Modified Covariance). Outputs: output_bwe: complex 1D array containing the time-domain radar signal after BWE. time_bwe_vect: float 1D array containing the time axis corresponding to output_bwe [s]. Notes: In this implementation, the time-domain output signal is scaled using the method described by Cuomo (1992). A Hamming window is applied to the spectrum before IFFT. Example 2 example scripts are proposed with the same synthetic radar scenario for the PyBWE package: An application of PyBWE.BWE on a synthetic radar signal is proposed in examples/script_example_PyBWE_BWE.py . A manual use of PyBWE.burg and PyBWE.ar_extrapolation on a synthetic radar signal is proposed in examples/script_example_PyBWE_extrapolation.py . In the following, these 2 scripts are explained as a single tutorial: Presentation of the scenario The synthetic radar signal example (inspired by the WISDOM GPR of the ExoMars rover mission, Ciarletti et al. (2017)): A SFCW (Stepped Frequency Continuous Wave) radar working between 0.5 and 3 GHz measures a 1001 frequencies spectrum when sounding. Only the In-phase component (real part of the spectrum) is measured, the Quadrature component (imaginary part of the spectrum) is reconstructed by Hilbert transform. Two targets in free-space are seperated by 5 cm, slightly below the radar's free-space resolution. These targets generate echoes of given complex amplitudes in the radar's signal, or complex sine-waves in the measured spectrum. The measured spectrum is corrupted by a white-noise of standard deviation 10X smaller than the complex sine-waves' amplitudes. The Bandwidth Extrapolation (BWE) is applied to this radar's signal using the PyBWE function_BWE: Most of the estimation errors when reconstructing a complex spectrum with the Hilbert transform are on the far sides of the spectrum. For this reason, we cut 5% of frequencies on each side of the spectrum before BWE. We would do the same for a radar working in time-domain, as most errors in FFT estimation are also on each side of the spectrum. This process is useless for a radar working in the frequency-domain and measuring both In-Phase and Quadrature components of the spectrum. We then fit an AR model to the spectrum, with an order equal to \u2153 of the spectrum samples, as recommended by Cuomo (1992). We use this model to extrapolate the spectrum on each side, to obtain a bandwidth 3X larger (maximum extrapolation factor recommended by Cuomo (1992)). A bandwidth X3 yields a resolution X3 better in time-domain. The extrapolated spectrum is eventually converted to a time-domain signal by IFFT, with zero-padding to interpolate the signal X10. This interpolation is purely aesthetic. This scenario requires the following libraries: import matplotlib.pyplot as plt import numpy as np from math import pi from scipy.signal import hilbert import PyBWE The synthetic signal generation In this section we describe how to generate analytically a synthetic radar sounding to test the PyBWE package. Generate a vector of 1001 frequencies between 0.5 and 3 GHz: freq_vect = np.linspace ( 0 .5e9,3e9,1001 ) Distance (m) between two radar targets in free-space (returning two echoes) and the radar: dist_target1 = 1 dist_target2 = 1 .07 Amplitude of the 2 echoes corresponding to the 2 targets: ampli_target1 = 1 ampli_target2 = 1 Generate a sum of two complex sine-waves corresponding to the targets' echoes (each with an amplitude of 1): spec_vect = ( ampli_target1*np.exp ( 1j*4*pi*dist_target1*freq_vect/3e8 )) + ( ampli_target2*np.exp ( 1j*4*pi*dist_target2*freq_vect/3e8 )) Only keep the real part of the spectrum (In-phase component): spec_vect = np.real ( spec_vect ) Add a white noise (standard deviation 0.1) to this spectrum signal: wn_vect = np.random.normal ( 0 ,0.1,spec_vect.shape ) spec_vect += wn_vect Reconstruct a complex signal with the Hilbert transform: spec_vect = hilbert ( spec_vect )[ ::2 ] freq_vect = freq_vect [ ::2 ] This is the signal to which we will apply the BWE. The application of the BWE: The BWE can be applied directly to the spectrum using the PyBWE.BWE function. Extrapolation factor (=< 3 recommended by Cuomo (1992)): extra_factor = 3 Order of the model as a ratio of the total number of samples in the spectrum (= 0.33 recommended by Cuomo (1992)): model_order = 0 .33 Zero-padding factor (= time domain interpolation factor): zp_factor = 10 Cut 5% of samples on each side of the spectrum: side_cut = True Method to determine the AR model: method = 'burg' Calculate the original spectrum's frequency step: df = freq_vect [ 1 ] -freq_vect [ 0 ] Application of the BWE to the spectrum: output_bwe, time_bwe_vect = PyBWE.BWE ( spec_vect,df,extra_factor,model_order,zp_factor,side_cut,method ) output_bwe contains the time-domain radar sounding after BWE, ready to be displayed with time axis time_bwe_vect. Display of the BWE results: In this section we display the BWE results compared to the original radar sounding. Generate a time vector corresponding to the time-domain transform: time_vect = np.linspace ( 0 ,1/df,zp_factor*len ( spec_vect )) Display the original radar sounding and the BWE version: plt.figure ( figsize =( 10 ,5 )) plt.plot ( time_vect*1e9,abs ( 1 .85*np.fft.fft ( spec_vect*np.hamming ( len ( spec_vect )) ,zp_factor*len ( spec_vect ))) /len ( spec_vect ) , 'k-' ) plt.plot ( time_bwe_vect*1e9,abs ( output_bwe ) , 'r-' ) plt.xlim ([ 5 ,9 ]) plt.ylim ([ -0.05,1.3 ]) plt.xlabel ( 'Time delays (ns)' ) plt.ylabel ( 'Normalized amplitude' ) plt.legend ([ 'Original radar sounding' , 'Radar sounding after BWE' ] , loc = 'best' ) plt.title ( 'BWE application' ) plt.grid () plt.tight_layout () plt.show () (The X 1.85 factor in amplitude corresponds to the compensation for the Hamming window). Here is an example of figure displayed with this command: Manual extrapolation: If you want to model and extrapolate the spectrum manually, it can also be done using the PyBWE.burg and PyBWE.ar_extrapolation functions. Cutting 5% of frequencies on each side of the spectrum: spec_vect = spec_vect [ round ( len ( spec_vect ) *0.05 ) :len ( spec_vect ) -round ( len ( spec_vect ) *0.05 )] freq_vect = freq_vect [ round ( len ( freq_vect ) *0.05 ) :len ( freq_vect ) -round ( len ( freq_vect ) *0.05 )] Retrieve the number of samples in the spectrum: N = len ( spec_vect ) Set the AR model's order as \u2153 of the number of samples: model_order_nb = round ( 0 .33*N ) Fit an AR model to the spectrum using the Burg algorithm: ar_coeff,ar_var,ar_rc = PyBWE.burg ( spec_vect,model_order_nb ) Number of samples to be extrapolated on each side of the spectrum to get an extrapolation factor of 3: Nextra = round ((( 3 *N ) -N ) //2 ) +1 Extrapolation on each side of the spectrum: spec_vect_extra,spec_vect_forward,spec_vect_backward = PyBWE.ar_extrapolation ( spec_vect,ar_coeff,Nextra, \"both\" ) spec_vect_extra is the extrapolated spectrum on both sides, spec_vect_forward and spec_vect_backward are the forward and backward extrapolations of the spectrum. Display of the extrapolation result: In this section, we display the AR-extrapolated spectrum, along with the expected spectrum (noise-free) after extrapolation for comparison. Generate the expected spectrum after extrapolation for comparison: df = freq_vect [ 1 ] -freq_vect [ 0 ] freq_vect_expected = np.linspace ( freq_vect [ 0 ] - ( df* ( Nextra-2 )) ,freq_vect [ -1 ] + ( df*Nextra ) ,N+ ( Nextra*2 )) spec_vect_expected = np.exp ( 1j*4*pi*dist_target1*freq_vect_expected/3e8 ) +np.exp ( 1j*4*pi*dist_target2*freq_vect_expected/3e8 ) Display the expected spectrum after extrapolation: plt.figure ( figsize =( 10 ,5 )) plt.plot ( freq_vect_expected*1e-9,np.real ( spec_vect_expected ) , 'r-' ) plt.plot ( freq_vect_expected*1e-9,abs ( spec_vect_expected ) , 'k-' ) plt.axvspan (( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ 0 ] -df ) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.axvspan (( freq_vect [ -1 ] +df ) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9 ]) plt.ylim ([ -2.1,2.1 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Real part' , 'Modulus' ] , loc = 'upper left' ) plt.title ( 'Expected spectrum after extrapolation' ) plt.grid () plt.tight_layout () plt.show () Here is an example of figure displayed with this command: Generate a vector of frequencies for the forward and backward extrapolations: freq_vect_forward = np.linspace ( freq_vect [ -1 ] +df,freq_vect [ -1 ] + ( df*Nextra ) ,Nextra ) freq_vect_backward = np.linspace ( freq_vect [ 0 ] - ( df* ( Nextra-2 )) ,freq_vect [ 0 ] -df,Nextra ) Display the original radar spectrum and the extrapolation: plt.figure ( figsize =( 10 ,5 )) plt.plot ( freq_vect*1e-9,np.real ( spec_vect ) , 'r-' ) plt.plot ( freq_vect*1e-9,abs ( spec_vect ) , 'k-' ) plt.plot ( freq_vect_backward*1e-9,np.real ( spec_vect_backward ) , 'y-' ) plt.plot ( freq_vect_backward*1e-9,abs ( spec_vect_backward ) , 'g-' ) plt.plot ( freq_vect_forward*1e-9,np.real ( spec_vect_forward ) , 'c-' ) plt.plot ( freq_vect_forward*1e-9,abs ( spec_vect_forward ) , 'b-' ) plt.axvspan (( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ 0 ] -df ) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.axvspan (( freq_vect [ -1 ] +df ) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9 ]) plt.ylim ([ -3,2.5 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.title ( 'Spectrum AR-extrapolation' ) plt.grid () plt.tight_layout () plt.legend ([ 'Original radar spectrum (real part)' , 'Original radar spectrum (modulus)' , 'Backward extrapolation (real part)' , 'Backward extrapolation (modulus)' , 'Forward extrapolation (real part)' , 'Forward extrapolation (modulus)' ] ,loc = 'lower center' ,ncol = 3 ) plt.show () Here is an example of figure displayed with this command: References Cuomo (1992) Ciarletti et al. (2017) Raguso et al. (2018) Herv\u00e9 et al. (2020) Oudart et al. (2021) Gambacorta et al. (2022)","title":"PyBWE"},{"location":"PyBWE/#pybwe-package","text":"","title":"PyBWE package"},{"location":"PyBWE/#description","text":"The PyBWE package is the \"plain vanilla\" package of this library. It allows you to apply the classic Bandwidth Extrapolation (BWE) technique as defined by Cuomo (1992) to any radar spectrum. The BWE is a super-resolution technique, as it yields a better range resolution in time-domain than classic spectral estimation techniques (FFT). The BWE works this way: The input is the frequency-domain spectrum of the radar's reponse signal from a series of targets. In this situation, the signal should in theory be a sum of complex sine-waves. An autoregressive (AR) model is fitted to this spectrum, using the Burg or the Modified Covariance algorithm. The order of the model is a user-defined parameter. This model is used to extrapolate the spectrum forward and backward. The extrapolating factor is a user-defined parameter. The super-resolved time-domain sounding is obtained by IFFT. Zero-padding can be used for time-domain interpolation (this process is purely aesthetic). The spectrum's extrapolation factor is equal to the resolution enhancement factor after IFFT. The PyBWE package contains the PyBWE.BWE function, allowing you to apply the BWE directly to a given radar spectrum and get a super-resolved sounding. This function calls several other functions from the package, that you can call independently if needed: PyBWE.burg: fits an AR model to a spectrum, using the Burg algorithm. PyBWE.mcov: fits an AR model to a spectrum, using the Modified Covariance algorithm. PyBWE.ar_extrapolation: extrapolates forward, backward or both a spectrum, given an AR model.","title":"Description"},{"location":"PyBWE/#importation","text":"Once the library is installed, the PyBWE package can simply be imported: import PyBWE","title":"Importation"},{"location":"PyBWE/#recommendations","text":"","title":"Recommendations"},{"location":"PyBWE/#the-order-of-the-ar-model","text":"In theory, the ideal order of an AR model depends on the number of complex sine-waves composing the spectrum. However, in practical cases, a higher order is required to obtain good results in presence of noise. For the BWE, Cuomo (1992) recommends an order equal to \u2153 of the number of samples in the spectrum.","title":"The order of the AR model"},{"location":"PyBWE/#the-extrapolation-factor","text":"In theory, a sum of sine-wave can be extrapolated infinitely. However, in practical cases, errors accumulate with the extrapolation. For the BWE, Cuomo (1992) recommends an extrapolation factor of maximum 3.","title":"The extrapolation factor"},{"location":"PyBWE/#the-effect-of-side-lobes","text":"In the case of a radar signal spectrum obtained by FFT, 2 effects must be mitigated before BWE: If a window was applied to the signal, it must be inverted. The application of the FFT generates side-lobes effects on the borders of the spectrum. For this reason, Cuomo (1992) recommends to remove 5% of frequencies on each side of a spectrum before BWE. In the case of a radar measuring only the real-part of a frequency spectrum, the imaginary part can be reconstructed by Hilbert transform. The FFT being part of Hilbert transform implementations, errors can also be expected on the border of the spectrum. We thus also recommend to cut 5% of samples on each side of a spectrum in this case. The PyBWE.BWE function allows you to remove 5% of samples on each side of a spectrum before BWE.","title":"The effect of side-lobes"},{"location":"PyBWE/#the-effect-of-distortions","text":"The BWE technique is based on the assumption that the spectrum of a radar response signal from targets is a sum of complex sine-waves. In many practical applications, a radar response signal can differ from this model, due to various distortion effects. Such distortions can make the application of the direct application of the BWE impossible. We thus recommend to correct distortions prior to a BWE application. Different solutions are possible for different sources of distortion: Effect of the antennas gain: No antenna can transmit all frequencies with the same gain. This will cause distortions of sine-waves in a radar spectrum. You can try to compensate for this effect with a calibration radar measurement on a \"perfect reflector\" (a metallic sphere or a large metallic plate). From the spectrum of the echo from such target, the antennas gain can be determined, and inverted in all other radar measurements. This process is sometimes called \"whitening\" and is described in Oudart et al. (2021). As different temperatures can lead to significantly different amplitudes over a radar's bandwidth, for a successful whitening process we recommend to apply first a temperature correction (as the one described in Herv\u00e9 et al. (2020)). Effect of the ionosphere: The ionosphere of any planet has a frequency-dependent attenuation effect on electromagnetic waves. This will cause distortions of sine-waves in a radar spectrum. This effect can be compensated using a ionospheric model. For instance Gambacorta et al. (2022) used a ionospheric Gamma model before applying the BWE to MARSIS (Mars Express) soundings. Effect of subsurface attenuations: When a radar signal is transmitted through a sub-surface, it is affected by different frequency-dependent attenuations (absorption, scattering...). It can thus be expected that deeper echoes in a high-loss subsurface will not be correctly reconstructed by BWE. We recommend to use the PySSBWE package, as the SSBWE (State-Space Bandwidth Extrapolation) technique accounts for such attenuations.","title":"The effect of distortions"},{"location":"PyBWE/#the-effect-of-noise","text":"The presence of noise in a signal impact the quality of the AR model determined by the Burg algorithm. For this reason, a high level of noise will impact the BWE results (echoes amplitudes and time-delays), as demonstrated in Oudart et al. (2021). To mitigate the effect of noise, we recommend to use a more complex model, like the ones provided in PyPBWE and PySSBWE packages.","title":"The effect of noise"},{"location":"PyBWE/#electromagnetic-interferences","text":"EM interferences can cause peaks in the measured radar spectrum. Such peaks will impair the AR modelling of the signal. The effect can be mitigated by detecting outliers in the spectrum, and then replacing them by interpolation, as proposed by Raguso et al. (2018).","title":"Electromagnetic interferences"},{"location":"PyBWE/#cross-talk","text":"If the emission and reception antennas / channels are not the same, a cross-talk phenomenon can generate unwanted signals in the radar response. It is recommended to remove such effects prior to the application of the BWE. This can for instance be done by subtracting a \"free-space\" (without any targets) calibration signal to any radar response.","title":"Cross-talk"},{"location":"PyBWE/#functions","text":"","title":"Functions"},{"location":"PyBWE/#pybwear_extrapolationxar_coeffnextraextra_modeboth","text":"The PyBWE.ar_extrapolation function extrapolates a spectrum given its AR model, forward, backward or both. Inputs: x: complex 1D array containing the spectrum to be extrapolated. ar_coeff: complex 1D array containing the coefficients of the spectrum's AR model. Nextra: integer number of samples to be extrapolated forward, backward or both. extra_mode: (optional) string containing the extrapolation mode, \"forward\"/\"backward\"/\"both\". Outputs: x_extra: complex 1D array containing the extrapolated spectrum. x_forward: complex 1D array containing the forward extrapolation, empty if in \"backward\" mode. x_backward: complex 1D array containing the backward extrapolation, empty if in \"forward\" mode.","title":"PyBWE.ar_extrapolation(x,ar_coeff,Nextra,extra_mode='both')"},{"location":"PyBWE/#pybweburgxp","text":"The PyBWE.burg function fits an AR model to a spectrum, using the Burg algorithm. Inputs: x: complex 1D array containing the spectrum to be modelled. p: integer order of the AR model. Outputs: a: complex 1D array containing the AR model coefficients. e: float estimated white-noise variance. rc: complex 1D array containing the Burg algorithm's reflection coefficients.","title":"PyBWE.burg(x,p)"},{"location":"PyBWE/#pybwemcovxp","text":"The PyBWE.mcov function fits an AR model to a spectrum, using the Modified Covariance algorithm. Inputs: x: complex 1D array containing the spectrum to be modelled. p: integer order of the AR model. Outputs: a: complex 1D array containing the AR model coefficients. e: float estimated white-noise variance.","title":"PyBWE.mcov(x,p)"},{"location":"PyBWE/#pybwebwespecdfextra_factormodel_orderzp_factorside_cuttruemethodburg","text":"The PyBWE.BWE function applies the Bandwidth Extrapolation to a radar signal's spectrum. Inputs: spec: complex 1D array containing the spectrum to which the BWE will be applied. df: float frequency step corresponding to spec [Hz]. extra_factor: float factor between the extrapolated and the original spectrum's bandwidths. model_order: float order of the AR model for extrapolation, expressed as a ratio of the original spectrum's bandwidth. zp_factor: float factor between the zero-padded and original spectrum's bandwidth. side_cut: (optional) boolean , 5% of samples are cut on each side of the spectrum if True. method: (optional) string name of the method to determine the AR model ('burg' for Burg, or 'mcov' for Modified Covariance). Outputs: output_bwe: complex 1D array containing the time-domain radar signal after BWE. time_bwe_vect: float 1D array containing the time axis corresponding to output_bwe [s]. Notes: In this implementation, the time-domain output signal is scaled using the method described by Cuomo (1992). A Hamming window is applied to the spectrum before IFFT.","title":"PyBWE.BWE(spec,df,extra_factor,model_order,zp_factor,side_cut=True,method='burg')"},{"location":"PyBWE/#example","text":"2 example scripts are proposed with the same synthetic radar scenario for the PyBWE package: An application of PyBWE.BWE on a synthetic radar signal is proposed in examples/script_example_PyBWE_BWE.py . A manual use of PyBWE.burg and PyBWE.ar_extrapolation on a synthetic radar signal is proposed in examples/script_example_PyBWE_extrapolation.py . In the following, these 2 scripts are explained as a single tutorial:","title":"Example"},{"location":"PyBWE/#presentation-of-the-scenario","text":"The synthetic radar signal example (inspired by the WISDOM GPR of the ExoMars rover mission, Ciarletti et al. (2017)): A SFCW (Stepped Frequency Continuous Wave) radar working between 0.5 and 3 GHz measures a 1001 frequencies spectrum when sounding. Only the In-phase component (real part of the spectrum) is measured, the Quadrature component (imaginary part of the spectrum) is reconstructed by Hilbert transform. Two targets in free-space are seperated by 5 cm, slightly below the radar's free-space resolution. These targets generate echoes of given complex amplitudes in the radar's signal, or complex sine-waves in the measured spectrum. The measured spectrum is corrupted by a white-noise of standard deviation 10X smaller than the complex sine-waves' amplitudes. The Bandwidth Extrapolation (BWE) is applied to this radar's signal using the PyBWE function_BWE: Most of the estimation errors when reconstructing a complex spectrum with the Hilbert transform are on the far sides of the spectrum. For this reason, we cut 5% of frequencies on each side of the spectrum before BWE. We would do the same for a radar working in time-domain, as most errors in FFT estimation are also on each side of the spectrum. This process is useless for a radar working in the frequency-domain and measuring both In-Phase and Quadrature components of the spectrum. We then fit an AR model to the spectrum, with an order equal to \u2153 of the spectrum samples, as recommended by Cuomo (1992). We use this model to extrapolate the spectrum on each side, to obtain a bandwidth 3X larger (maximum extrapolation factor recommended by Cuomo (1992)). A bandwidth X3 yields a resolution X3 better in time-domain. The extrapolated spectrum is eventually converted to a time-domain signal by IFFT, with zero-padding to interpolate the signal X10. This interpolation is purely aesthetic. This scenario requires the following libraries: import matplotlib.pyplot as plt import numpy as np from math import pi from scipy.signal import hilbert import PyBWE","title":"Presentation of the scenario"},{"location":"PyBWE/#the-synthetic-signal-generation","text":"In this section we describe how to generate analytically a synthetic radar sounding to test the PyBWE package. Generate a vector of 1001 frequencies between 0.5 and 3 GHz: freq_vect = np.linspace ( 0 .5e9,3e9,1001 ) Distance (m) between two radar targets in free-space (returning two echoes) and the radar: dist_target1 = 1 dist_target2 = 1 .07 Amplitude of the 2 echoes corresponding to the 2 targets: ampli_target1 = 1 ampli_target2 = 1 Generate a sum of two complex sine-waves corresponding to the targets' echoes (each with an amplitude of 1): spec_vect = ( ampli_target1*np.exp ( 1j*4*pi*dist_target1*freq_vect/3e8 )) + ( ampli_target2*np.exp ( 1j*4*pi*dist_target2*freq_vect/3e8 )) Only keep the real part of the spectrum (In-phase component): spec_vect = np.real ( spec_vect ) Add a white noise (standard deviation 0.1) to this spectrum signal: wn_vect = np.random.normal ( 0 ,0.1,spec_vect.shape ) spec_vect += wn_vect Reconstruct a complex signal with the Hilbert transform: spec_vect = hilbert ( spec_vect )[ ::2 ] freq_vect = freq_vect [ ::2 ] This is the signal to which we will apply the BWE.","title":"The synthetic signal generation"},{"location":"PyBWE/#the-application-of-the-bwe","text":"The BWE can be applied directly to the spectrum using the PyBWE.BWE function. Extrapolation factor (=< 3 recommended by Cuomo (1992)): extra_factor = 3 Order of the model as a ratio of the total number of samples in the spectrum (= 0.33 recommended by Cuomo (1992)): model_order = 0 .33 Zero-padding factor (= time domain interpolation factor): zp_factor = 10 Cut 5% of samples on each side of the spectrum: side_cut = True Method to determine the AR model: method = 'burg' Calculate the original spectrum's frequency step: df = freq_vect [ 1 ] -freq_vect [ 0 ] Application of the BWE to the spectrum: output_bwe, time_bwe_vect = PyBWE.BWE ( spec_vect,df,extra_factor,model_order,zp_factor,side_cut,method ) output_bwe contains the time-domain radar sounding after BWE, ready to be displayed with time axis time_bwe_vect.","title":"The application of the BWE:"},{"location":"PyBWE/#display-of-the-bwe-results","text":"In this section we display the BWE results compared to the original radar sounding. Generate a time vector corresponding to the time-domain transform: time_vect = np.linspace ( 0 ,1/df,zp_factor*len ( spec_vect )) Display the original radar sounding and the BWE version: plt.figure ( figsize =( 10 ,5 )) plt.plot ( time_vect*1e9,abs ( 1 .85*np.fft.fft ( spec_vect*np.hamming ( len ( spec_vect )) ,zp_factor*len ( spec_vect ))) /len ( spec_vect ) , 'k-' ) plt.plot ( time_bwe_vect*1e9,abs ( output_bwe ) , 'r-' ) plt.xlim ([ 5 ,9 ]) plt.ylim ([ -0.05,1.3 ]) plt.xlabel ( 'Time delays (ns)' ) plt.ylabel ( 'Normalized amplitude' ) plt.legend ([ 'Original radar sounding' , 'Radar sounding after BWE' ] , loc = 'best' ) plt.title ( 'BWE application' ) plt.grid () plt.tight_layout () plt.show () (The X 1.85 factor in amplitude corresponds to the compensation for the Hamming window). Here is an example of figure displayed with this command:","title":"Display of the BWE results:"},{"location":"PyBWE/#manual-extrapolation","text":"If you want to model and extrapolate the spectrum manually, it can also be done using the PyBWE.burg and PyBWE.ar_extrapolation functions. Cutting 5% of frequencies on each side of the spectrum: spec_vect = spec_vect [ round ( len ( spec_vect ) *0.05 ) :len ( spec_vect ) -round ( len ( spec_vect ) *0.05 )] freq_vect = freq_vect [ round ( len ( freq_vect ) *0.05 ) :len ( freq_vect ) -round ( len ( freq_vect ) *0.05 )] Retrieve the number of samples in the spectrum: N = len ( spec_vect ) Set the AR model's order as \u2153 of the number of samples: model_order_nb = round ( 0 .33*N ) Fit an AR model to the spectrum using the Burg algorithm: ar_coeff,ar_var,ar_rc = PyBWE.burg ( spec_vect,model_order_nb ) Number of samples to be extrapolated on each side of the spectrum to get an extrapolation factor of 3: Nextra = round ((( 3 *N ) -N ) //2 ) +1 Extrapolation on each side of the spectrum: spec_vect_extra,spec_vect_forward,spec_vect_backward = PyBWE.ar_extrapolation ( spec_vect,ar_coeff,Nextra, \"both\" ) spec_vect_extra is the extrapolated spectrum on both sides, spec_vect_forward and spec_vect_backward are the forward and backward extrapolations of the spectrum.","title":"Manual extrapolation:"},{"location":"PyBWE/#display-of-the-extrapolation-result","text":"In this section, we display the AR-extrapolated spectrum, along with the expected spectrum (noise-free) after extrapolation for comparison. Generate the expected spectrum after extrapolation for comparison: df = freq_vect [ 1 ] -freq_vect [ 0 ] freq_vect_expected = np.linspace ( freq_vect [ 0 ] - ( df* ( Nextra-2 )) ,freq_vect [ -1 ] + ( df*Nextra ) ,N+ ( Nextra*2 )) spec_vect_expected = np.exp ( 1j*4*pi*dist_target1*freq_vect_expected/3e8 ) +np.exp ( 1j*4*pi*dist_target2*freq_vect_expected/3e8 ) Display the expected spectrum after extrapolation: plt.figure ( figsize =( 10 ,5 )) plt.plot ( freq_vect_expected*1e-9,np.real ( spec_vect_expected ) , 'r-' ) plt.plot ( freq_vect_expected*1e-9,abs ( spec_vect_expected ) , 'k-' ) plt.axvspan (( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ 0 ] -df ) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.axvspan (( freq_vect [ -1 ] +df ) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9 ]) plt.ylim ([ -2.1,2.1 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Real part' , 'Modulus' ] , loc = 'upper left' ) plt.title ( 'Expected spectrum after extrapolation' ) plt.grid () plt.tight_layout () plt.show () Here is an example of figure displayed with this command: Generate a vector of frequencies for the forward and backward extrapolations: freq_vect_forward = np.linspace ( freq_vect [ -1 ] +df,freq_vect [ -1 ] + ( df*Nextra ) ,Nextra ) freq_vect_backward = np.linspace ( freq_vect [ 0 ] - ( df* ( Nextra-2 )) ,freq_vect [ 0 ] -df,Nextra ) Display the original radar spectrum and the extrapolation: plt.figure ( figsize =( 10 ,5 )) plt.plot ( freq_vect*1e-9,np.real ( spec_vect ) , 'r-' ) plt.plot ( freq_vect*1e-9,abs ( spec_vect ) , 'k-' ) plt.plot ( freq_vect_backward*1e-9,np.real ( spec_vect_backward ) , 'y-' ) plt.plot ( freq_vect_backward*1e-9,abs ( spec_vect_backward ) , 'g-' ) plt.plot ( freq_vect_forward*1e-9,np.real ( spec_vect_forward ) , 'c-' ) plt.plot ( freq_vect_forward*1e-9,abs ( spec_vect_forward ) , 'b-' ) plt.axvspan (( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ 0 ] -df ) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.axvspan (( freq_vect [ -1 ] +df ) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9 ]) plt.ylim ([ -3,2.5 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.title ( 'Spectrum AR-extrapolation' ) plt.grid () plt.tight_layout () plt.legend ([ 'Original radar spectrum (real part)' , 'Original radar spectrum (modulus)' , 'Backward extrapolation (real part)' , 'Backward extrapolation (modulus)' , 'Forward extrapolation (real part)' , 'Forward extrapolation (modulus)' ] ,loc = 'lower center' ,ncol = 3 ) plt.show () Here is an example of figure displayed with this command:","title":"Display of the extrapolation result:"},{"location":"PyBWE/#references","text":"Cuomo (1992) Ciarletti et al. (2017) Raguso et al. (2018) Herv\u00e9 et al. (2020) Oudart et al. (2021) Gambacorta et al. (2022)","title":"References"},{"location":"PyPBWE/","text":"PyPBWE package Description The PyPBWE package is an \"advanced\" package of this library. It allows you to apply the Polarimetric Bandwidth Extrapolation (PBWE) technique as defined by Suwa and Iwamoto (2003,2007) to any set of multi-polarimetric-channel radar spectra. The PBWE is a super-resolution technique, as it yields a better range resolution in time-domain than classic spectral estimation techniques (FFT). It is a multi-channel version of the classic Bandwidth Extrapolation (BWE), taking advantage of the polarimetric capabilities of a radar. The PBWE works this way: The input is a set of frequency-domain spectra of the radar's reponse signals from a series of targets, received by different polarimetric channels of the instrument. In this situation, each channel signal should in theory be a sum of complex sine-waves. A set of autoregressive (AR) models is fitted to this set of spectra, using a multi-channel version of the Burg algorithm. The order of the model is a user-defined parameter. These models are used to extrapolate each spectrum forward and backward. The extrapolating factor is a user-defined parameter. The super-resolved time-domain soundings for each channel are obtained by IFFT. Zero-padding can be used for time-domain interpolation (this process is purely aesthetic). Each spectrum's extrapolation factor is equal to the resolution enhancement factor after IFFT. The multi-channel version of the Burg algorithm used by the PBWE accounts for the targets' echoes information present in each polarimetric channel: the principle of this technique consists in extrapolating each polarimetric channel with a weighted sum of previous/next samples not only using this channel but also the others. For this reason, in the case where a target's scattering coefficients are different and non-zero for at least two polarimetric channels of the radar, we expect the PBWE to perform better than the BWE. The PyPBWE package contains the PyPBWE.PBWE function, allowing you to apply the PBWE directly to a given set of multi-polarimetric-channel radar spectra and get a super-resolved sounding per channel. This function calls several other functions from the package, that you can call independently if needed: PyPBWE.polar_burg: fits an AR model to each polarimetric channel of a spectrum, using a multi-channel version of the Burg algorithm. PyPBWE.polar_extrapolation: extrapolates forward, backward or both a multi-polarimetric-channel spectrum, given a set of AR models. Importation Once the library is installed, the PyPBWE package can simply be imported: import PyPBWE Recommendations The order of the AR model In theory, the ideal order of an AR model depends on the number of complex sine-waves composing the spectrum. However, in practical cases, a higher order is required to obtain good results in presence of noise. For the BWE, Cuomo (1992) recommends an order equal to \u2153 of the number of samples in the spectrum. This is also what we recommend for PBWE. The extrapolation factor In theory, a sum of sine-wave can be extrapolated infinitely. However, in practical cases, errors accumulate with the extrapolation. For the BWE, Cuomo (1992) recommends an extrapolation factor of maximum 3. Higher values can be tried for the PBWE, as the model is expected to be more robust, but the results must be interpreted cautiously. The effect of side-lobes In the case of a radar signal spectrum obtained by FFT, 2 effects must be mitigated before PBWE: If a window was applied to any signal channel, it must be inverted. The application of the FFT generates side-lobes effects on the borders of a spectrum. For this reason, Cuomo (1992) recommends to remove 5% of frequencies on each side of a spectrum before PBWE. The same goes for PBWE. In the case of a radar measuring only the real-part of each frequency spectrum, the imaginary part can be reconstructed by Hilbert transform. The FFT being part of Hilbert transform implementations, errors can also be expected on the border of reconstructed spectra. We thus also recommend to cut 5% of samples on each side of each polarimetric channel spectrum in this case. The PyPBWE.PBWE function allows you to remove 5% of samples on each side of a spectrum before PBWE. The effect of distortions The PBWE technique is based on the assumption that a target response signal will be a complex sine-wave of the same frequency (but potentially different amplitudes) in all polarimetric channels of a radar. In many practical applications, a radar response signal can differ from this model, due to various distortion effects. Such distortions can make the application of the direct application of the PBWE impossible. We thus recommend to correct distortions prior to a PBWE application. Different solutions are possible for different sources of distortion: Effect of the antennas gain: No antenna can transmit all frequencies with the same gain. This will cause distortions of sine-waves in a radar spectrum. You can try to compensate for this effect with a calibration radar measurement on a \"perfect reflector\" (a metallic sphere or a large metallic plate). From the spectrum of the echo from such target, the antennas gain can be determined, and inverted in all other radar measurements. This process is sometimes called \"whitening\" and is described in Oudart et al. (2021). As different temperatures can lead to significantly different amplitudes over a radar's bandwidth, for a successful whitening process we recommend to apply first a temperature correction (as the one described in Herv\u00e9 et al. (2020)). If necessary, we recommend to apply this process for all polarimetric channels of the radar. Effect of the ionosphere: The ionosphere of any planet has a frequency-dependent attenuation effect on electromagnetic waves. This will cause distortions of sine-waves in a radar spectrum. This effect can be compensated using a ionospheric model. For instance Gambacorta et al. (2022) used a ionospheric Gamma model before applying the PBWE to MARSIS (Mars Express) soundings. If necessary, we recommend to apply this process for all polarimetric channels of the radar. Effect of subsurface attenuations: When a radar signal is transmitted through a sub-surface, it is affected by different frequency-dependent attenuations (absorption, scattering...). It can thus be expected that deeper echoes in a high-loss subsurface will not be correctly reconstructed by PBWE. We recommend to use the PySSBWE package, as the SSBWE (State-Space Bandwidth Extrapolation) technique accounts for such attenuations. The effect of noise The presence of noise in a signal impact the quality of the AR model determined by the Burg algorithm. For this reason, a high level of noise will impact the BWE results (echoes amplitudes and time-delays), as demonstrated in Oudart et al. (2021). We expect this effect to be lower for the PBWE than for the BWE in the case of targets having different non-zero scattering coefficients in at least two polarimetric channels of the radar. Electromagnetic interferences EM interferences can cause peaks in the measured radar spectrum. Such peaks will impair the AR modelling of the signal. The effect can be mitigated by detecting outliers in the spectrum, and then replacing them by interpolation, as proposed by Raguso et al. (2018). If necessary, we recommend to apply this process for all polarimetric channels of the radar using the multi-channel Burg algorithm and extrapolation. Cross-talk If the emission and reception antennas / channels are not the same, a cross-talk phenomenon can generate unwanted signals in the radar response. It is recommended to remove such effects prior to the application of the BWE. This can for instance be done by subtracting a \"free-space\" (without any targets) calibration signal to any radar response. We thus recommend to acquire a \"free-space\" measurement for each polarimetric channel of the radar, and to subtract it to any radar response coming from this channel. Functions PyPBWE.PBWE(spec_mat,df,extra_factor,model_order,zp_factor,side_cut=True) The PyPBWE.PBWE function applies the Polarimetric Bandwidth Extrapolation to a radar polarimetric channels spectra. Inputs: spec_mat: complex 2D array , each row containing the spectrum of a polarimetric channel to be extrapolated. df: float frequency step corresponding to spec_mat [Hz]. extra_factor: float factor between the extrapolated and the original spectra's bandwidths. model_order: float order of the AR models for extrapolation, expressed as a ratio of the original spectra's bandwidth. zp_factor: float factor between the zero-padded and original spectra's bandwidth. side_cut: (optional) boolean , 5% of samples are cut on each side of each spectra if True. Outputs: output_pbwe: complex 2D array , each row containing the time-domain radar signal of a polarimetric channel after PBWE. time_pbwe_vect: float 1D array containing the time axis corresponding to output_pbwe [s]. Notes: In this implementation, the time-domain output signal is scaled by the number of samples in each polarimetric channel's spectrum. A Hamming window is applied to each spectrum before IFFT. PyPBWE.polar_burg(X,p) The PyPBWE.polar_burg function fits an AR model to each polarimetric channel's spectrum, using a multi-channel version of the Burg algorithm. Inputs: X: complex 2D array , each row containing the spectrum of a polarimetric channel to be modelled. p: integer order of the AR models. Outputs: Thetaf: complex 2D array containing the coefficients of the multi-channel AR forward model. Thetab: complex 2D array containing the coefficients of the multi-channel AR backward model. err: float 1D array of prediction errors (forward/backward). PyPBWE.polar_extrapolation(X,Thetaf,Thetab,Mextra,extra_mode='both') The PyPBWE.polar_extrapolation function extrapolates a set of polarimetric channel spectra given their multi-channel AR model, forward, backward or both. Inputs: X: complex 2D array , each row containing the spectrum of a polarimetric channel to be extrapolated. Thetaf: complex 2D array containing the coefficients of the multi-channel AR forward model. Thetab: complex 2D array containing the coefficients of the multi-channel AR backward model. Mextra: integer number of samples to be extrapolated forward, backward or both for each channel. extra_mode: (optional) string containing the extrapolation mode, \"forward\"/\"backward\"/\"both\". Outputs: X_extra: complex 2D array , each row containing the extrapolated spectrum of a polarimetric channel. X_forward: complex 2D array , each row containing the forward extrapolation of a polarimetric channel. X_backward: complex 2D array , each row containing the backward extrapolation of a polarimetric channel. Example 2 example scripts are proposed with the same synthetic radar scenario for the PyBWE package: An application of PyPBWE.PBWE on a synthetic radar signal is proposed in examples/script_example_PyPBWE_PBWE.py . A manual use of PyPBWE.polar_burg and PyPBWE.polar_extrapolation on a synthetic radar signal is proposed in examples/script_example_PyPBWE_extrapolation.py . In the following, these 2 scripts are explained as a single tutorial: Presentation of the scenario The synthetic radar signal example (inspired by the WISDOM GPR of the ExoMars rover mission, Ciarletti et al. (2017)): A SFCW (Stepped Frequency Continuous Wave) radar working between 0.5 and 3 GHz measures a 1001 frequencies spectrum when sounding. This radar can transmit and receive signals in two linear polarizations named 0 and 1. This leads to 4 polirization channels: 2 co-polar named 00 and 11 (emission and reception in the same polarization), and 2 cross-polar named 01 and 10 (emission and reception in different polarizations). For simplicity, we will only consider the co-polar channels 00 and 11 in this example. Only the In-phase component (real part of the spectrum) is measured, the Quadrature component (imaginary part of the spectrum) is reconstructed by Hilbert transform. Two targets in free-space are seperated by 5 cm, slightly below the radar's free-space resolution. These targets generate echoes of given complex amplitudes in the radar's signal, or complex sine-waves in the measured spectrum. The measured spectrum is corrupted by a white-noise of standard deviation 10X smaller than the complex sine-waves' amplitudes. The Polarimetric Bandwidth Extrapolation (PBWE) is applied to this radar's signal using the PyBWE function_PBWE: Most of the estimation errors when reconstructing a complex spectrum with the Hilbert transform are on the far sides of the spectrum. For this reason, we cut 5% of frequencies on each side of the spectrum before PBWE. We would do the same for a radar working in time-domain, as most errors in FFT estimation are also on each side of the multi-channel spectrum. This process is useless for a radar working in the frequency-domain and measuring both In-Phase and Quadrature components of the spectrum. We then fit an AR model to the multi-channel spectrum, with an order equal to \u2153 of the spectrum samples, as recommended by Cuomo (1992). We use this model to extrapolate the spectrum on each side, to obtain a bandwidth 3X larger (maximum extrapolation factor recommended by Cuomo (1992)). A bandwidth X3 yields a resolution X3 better in time-domain. The extrapolated multi-channel spectrum is eventually converted to a one time-domain signal per channel with IFFT, and zero-padding to interpolate the signal X10. This interpolation is purely aesthetic. This scenario requires the following libraries: import matplotlib.pyplot as plt import numpy as np from math import pi from scipy.signal import hilbert import PyPBWE The synthetic signal generation In this section we describe how to generate analytically a synthetic radar sounding to test the PyPBWE package. Generate a vector of 1001 frequencies between 0.5 and 3 GHz: freq_vect = np.linspace ( 0 .5e9,3e9,1001 ) Distance (m) between two radar targets in free-space (returning two echoes) and the radar: dist_target1 = 1 dist_target2 = 1 .07 Amplitude associated with each target echo for each polarimetric channel: amp_target1_00 = 1 amp_target2_00 = 1 amp_target1_11 = 1 amp_target2_11 = -1 Generate a sum of two complex sine-waves corresponding to the targets' echoes (each with an amplitude of 1), for the 00 channel: spec_vect_00 = ( amp_target1_00*np.exp ( 1j*4*pi*dist_target1*freq_vect/3e8 )) + ( amp_target2_00*np.exp ( 1j*4*pi*dist_target2*freq_vect/3e8 )) Generate a sum of two complex sine-waves corresponding to the targets' echoes (with amplitudes of 1 and -1), for the 11 channel: spec_vect_11 = ( amp_target1_11*np.exp ( 1j*4*pi*dist_target1*freq_vect/3e8 )) + ( amp_target2_11*np.exp ( 1j*4*pi*dist_target2*freq_vect/3e8 )) Only keep the real part of the spectrum (In-phase component) for the 2 channels: spec_vect_00 = np.real ( spec_vect_00 ) spec_vect_11 = np.real ( spec_vect_11 ) Add a white noise (standard deviation 0.1) to each spectrum signal: wn_vect_00 = np.random.normal ( 0 ,0.1,spec_vect_00.shape ) wn_vect_11 = np.random.normal ( 0 ,0.1,spec_vect_11.shape ) spec_vect_00 += wn_vect_00 spec_vect_11 += wn_vect_11 Reconstruct a complex signal with the Hilbert transform for the 2 channels: spec_vect_00 = hilbert ( spec_vect_00 )[ ::2 ] spec_vect_11 = hilbert ( spec_vect_11 )[ ::2 ] freq_vect = freq_vect [ ::2 ] Assemble the 2 spectrum channels into a single matrix: spec_mat = np.vstack (( spec_vect_00,spec_vect_11 )) This is the matrix of signals to which we will apply the PBWE. The application of the PBWE: The PBWE can be applied directly to the multi-channel spectrum using the PyPBWE.PBWE function. Extrapolation factor (=< 3 recommended by Cuomo (1992)): extra_factor = 3 Order of the model as a ratio of the total number of samples in each spectrum (= 0.33 recommended by Cuomo (1992)): model_order = 0 .33 Zero-padding factor (= time domain interpolation factor): zp_factor = 10 Cut 5% of samples on each side of the 2 spectra: side_cut = True Calculate the spectrum's frequency step: df = freq_vect [ 1 ] -freq_vect [ 0 ] Application of the PBWE to the 2 polarimetric channels' spectra: output_pbwe, time_pbwe_vect = PyPBWE.PBWE ( spec_mat,df,extra_factor,model_order,zp_factor,side_cut ) output_bwe matrix contains the time-domain radar soundings after PBWE, ready to be displayed with time axis time_pbwe_vect. Display of the PBWE results: In this section we display the PBWE results compared to the original radar soundings for polarimetric channels 00 and 11. Generate a time vector corresponding to the time-domain transform: time_vect = np.linspace ( 0 ,1/df,zp_factor*np.shape ( spec_mat )[ 1 ]) Display the original radar sounding and the PBWE version for channel 00: plt.figure ( figsize =( 12 .75,5 )) plt.subplot ( 1 ,2,1 ) plt.plot ( time_vect*1e9,abs ( 1 .85*np.fft.fft ( spec_mat [ 0 ,: ] *np.hamming ( len ( spec_mat [ 0 ,: ])) ,zp_factor*len ( spec_mat [ 0 ,: ]))) /len ( spec_mat [ 0 ,: ]) , 'k-' ) plt.plot ( time_pbwe_vect*1e9,abs ( output_pbwe [ 0 ,: ]) , 'r-' ) plt.xlim ([ 5 ,9 ]) plt.ylim ([ -0.05,1.3 ]) plt.xlabel ( 'Time delays (ns)' ) plt.ylabel ( 'Normalized amplitude' ) plt.legend ([ 'Original radar sounding' , 'Radar sounding after PBWE' ] , loc = 'best' ) plt.title ( 'PBWE application - Polar channel 00' ) plt.grid () Display the original radar sounding and the PBWE version for channel 00: plt.subplot ( 1 ,2,2 ) plt.plot ( time_vect*1e9,abs ( 1 .85*np.fft.fft ( spec_mat [ 1 ,: ] *np.hamming ( len ( spec_mat [ 1 ,: ])) ,zp_factor*len ( spec_mat [ 1 ,: ]))) /len ( spec_mat [ 1 ,: ]) , 'k-' ) plt.plot ( time_pbwe_vect*1e9,abs ( output_pbwe [ 1 ,: ]) , 'r-' ) plt.xlim ([ 5 ,9 ]) plt.ylim ([ -0.05,1.3 ]) plt.xlabel ( 'Time delays (ns)' ) plt.ylabel ( 'Normalized amplitude' ) plt.legend ([ 'Original radar sounding' , 'Radar sounding after PBWE' ] , loc = 'best' ) plt.title ( 'PBWE application - Polar channel 11' ) plt.grid () plt.tight_layout () plt.show () (The X 1.85 factor in amplitude corresponds to the compensation for the Hamming window). Here is an example of figure displayed with this command: Manual extrapolation: If you want to model and extrapolate the multi-channel spectrum manually, it can also be done using the PyPBWE.polar_burg and PyPBWE.polar_extrapolation functions. Cutting 5% of frequencies on each side of the spectrum: spec_mat = spec_mat [ :,round ( np.shape ( spec_mat )[ 1 ] *0.05 ) :np.shape ( spec_mat )[ 1 ] -round ( np.shape ( spec_mat )[ 1 ] *0.05 )] freq_vect = freq_vect [ round ( len ( freq_vect ) *0.05 ) :len ( freq_vect ) -round ( len ( freq_vect ) *0.05 )] Retrieve the number of polarimetric channels: Npol = np.shape ( spec_mat )[ 0 ] Retrieve the new number of samples in the spectrum: M = np.shape ( spec_mat )[ 1 ] Set the multichannel AR model's order as \u2153 of the number of samples: model_order_nb = round ( 0 .33*M ) Fit a multichannel AR model to spec_mat: [ Thetaf,Thetab,err ] = PyPBWE.polar_burg ( spec_mat,model_order_nb ) Number of samples to be extrapolated on each side of the multichannel spectrum to get an extrapolation factor of 3: Mextra = round ((( 3 *M ) -M ) //2 ) +1 Extrapolation of spec_mat on each side of the multichannel spectrum: spec_mat_extra,spec_mat_extra_forward,spec_mat_extra_backward = PyPBWE.polar_extrapolation ( spec_mat,Thetaf,Thetab,Mextra, \"both\" ) spec_mat_extra is the extrapolated multichannel spectrum on both sides, spec_mat_extra_forward and spec_mat_extra_backward are the forward and backward extrapolations of this multichannel spectrum. Display of the extrapolation result: In this section, we display the polarimetric extrapolated spectra (channels 00 and 11), along with the expected spectra (noise-free) after extrapolation for comparison. Generate the expected spectrum after extrapolation for comparison: df = freq_vect [ 1 ] -freq_vect [ 0 ] freq_vect_expected = np.linspace ( freq_vect [ 0 ] - ( df* ( Mextra-2 )) ,freq_vect [ -1 ] + ( df*Mextra ) ,M+ ( Mextra*2 )) spec_vect_expected_00 = np.exp ( 1j*4*pi*dist_target1*freq_vect_expected/3e8 ) +np.exp ( 1j*4*pi*dist_target2*freq_vect_expected/3e8 ) spec_vect_expected_11 = np.exp ( 1j*4*pi*dist_target1*freq_vect_expected/3e8 ) -np.exp ( 1j*4*pi*dist_target2*freq_vect_expected/3e8 ) Display the expected spectrum after extrapolation for the 00 and 11 channels: plt.figure ( figsize =( 10 ,6 )) plt.subplot ( 2 ,1,1 ) plt.plot ( freq_vect_expected*1e-9,np.real ( spec_vect_expected_00 ) , 'r-' ) plt.plot ( freq_vect_expected*1e-9,abs ( spec_vect_expected_00 ) , 'k-' ) plt.axvspan (( freq_vect [ 0 ] - ( df* ( Mextra-2 ))) *1e-9, ( freq_vect [ 0 ] -df ) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.axvspan (( freq_vect [ -1 ] +df ) *1e-9, ( freq_vect [ -1 ] + ( df*Mextra )) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Mextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Mextra )) *1e-9 ]) plt.ylim ([ -2.5,3 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Real part' , 'Modulus' ] ,loc = 'upper left' ,ncol = 2 ) plt.title ( 'Expected spectrum after extrapolation - Polar channel 00' ) plt.grid () plt.subplot ( 2 ,1,2 ) plt.plot ( freq_vect_expected*1e-9,np.real ( spec_vect_expected_11 ) , 'r-' ) plt.plot ( freq_vect_expected*1e-9,abs ( spec_vect_expected_11 ) , 'k-' ) plt.axvspan (( freq_vect [ 0 ] - ( df* ( Mextra-2 ))) *1e-9, ( freq_vect [ 0 ] -df ) *1e-9,facecolor = 'k' ,alpha = 0 .1 ) plt.axvspan (( freq_vect [ -1 ] +df ) *1e-9, ( freq_vect [ -1 ] + ( df*Mextra )) *1e-9,facecolor = 'k' ,alpha = 0 .1 ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Mextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Mextra )) *1e-9 ]) plt.ylim ([ -2.5,3 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Real part' , 'Modulus' ] ,loc = 'upper left' ,ncol = 2 ) plt.title ( 'Expected spectrum after extrapolation - Polar channel 11' ) plt.grid () plt.tight_layout () plt.show () Here is an example of figure displayed with this command: Generate a vector of frequencies for the forward and backward extrapolations: freq_vect_forward = np.linspace ( freq_vect [ -1 ] +df,freq_vect [ -1 ] + ( df*Mextra ) ,Mextra ) freq_vect_backward = np.linspace ( freq_vect [ 0 ] - ( df* ( Mextra-2 )) ,freq_vect [ 0 ] -df,Mextra ) Display the original radar spectrum and the extrapolation for the 00 and 11 channels: plt.figure ( figsize =( 11 ,6 )) plt.subplot ( 2 ,1,1 ) plt.plot ( freq_vect*1e-9,np.real ( spec_mat [ 0 ,: ]) , 'r-' ) plt.plot ( freq_vect*1e-9,abs ( spec_mat [ 0 ,: ]) , 'k-' ) plt.plot ( freq_vect_backward*1e-9,np.real ( spec_mat_extra_backward [ 0 ,: ]) , 'y-' ) plt.plot ( freq_vect_backward*1e-9,abs ( spec_mat_extra_backward [ 0 ,: ]) , 'g-' ) plt.plot ( freq_vect_forward*1e-9,np.real ( spec_mat_extra_forward [ 0 ,: ]) , 'c-' ) plt.plot ( freq_vect_forward*1e-9,abs ( spec_mat_extra_forward [ 0 ,: ]) , 'b-' ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Mextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Mextra )) *1e-9 ]) plt.ylim ([ -3.6,2.3 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Original radar spectrum (real part)' , 'Original radar spectrum (modulus)' , 'Backward extrapolation (real part)' , 'Backward extrapolation (modulus)' , 'Forward extrapolation (real part)' , 'Forward extrapolation (modulus)' ] ,loc = 'lower center' ,ncol = 3 ) plt.title ( 'Spectrum polarimetric extrapolation - Polar channel 00' ) plt.grid () plt.subplot ( 2 ,1,2 ) plt.plot ( freq_vect*1e-9,np.real ( spec_mat [ 1 ,: ]) , 'r-' ) plt.plot ( freq_vect*1e-9,abs ( spec_mat [ 1 ,: ]) , 'k-' ) plt.plot ( freq_vect_backward*1e-9,np.real ( spec_mat_extra_backward [ 1 ,: ]) , 'y-' ) plt.plot ( freq_vect_backward*1e-9,abs ( spec_mat_extra_backward [ 1 ,: ]) , 'g-' ) plt.plot ( freq_vect_forward*1e-9,np.real ( spec_mat_extra_forward [ 1 ,: ]) , 'c-' ) plt.plot ( freq_vect_forward*1e-9,abs ( spec_mat_extra_forward [ 1 ,: ]) , 'b-' ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Mextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Mextra )) *1e-9 ]) plt.ylim ([ -3.6,2.3 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Original radar spectrum (real part)' , 'Original radar spectrum (modulus)' , 'Backward extrapolation (real part)' , 'Backward extrapolation (modulus)' , 'Forward extrapolation (real part)' , 'Forward extrapolation (modulus)' ] ,loc = 'lower center' ,ncol = 3 ) plt.title ( 'Spectrum polarimetric extrapolation - Polar channel 11' ) plt.grid () plt.tight_layout () plt.show () Here is an example of figure displayed with this command: References Cuomo (1992) Suwa and Iwamoto (2003) Suwa and Iwamoto (2007) Ciarletti et al. (2017) Raguso et al. (2018) Herv\u00e9 et al. (2020) Oudart et al. (2021) Gambacorta et al. (2022)","title":"PyPBWE"},{"location":"PyPBWE/#pypbwe-package","text":"","title":"PyPBWE package"},{"location":"PyPBWE/#description","text":"The PyPBWE package is an \"advanced\" package of this library. It allows you to apply the Polarimetric Bandwidth Extrapolation (PBWE) technique as defined by Suwa and Iwamoto (2003,2007) to any set of multi-polarimetric-channel radar spectra. The PBWE is a super-resolution technique, as it yields a better range resolution in time-domain than classic spectral estimation techniques (FFT). It is a multi-channel version of the classic Bandwidth Extrapolation (BWE), taking advantage of the polarimetric capabilities of a radar. The PBWE works this way: The input is a set of frequency-domain spectra of the radar's reponse signals from a series of targets, received by different polarimetric channels of the instrument. In this situation, each channel signal should in theory be a sum of complex sine-waves. A set of autoregressive (AR) models is fitted to this set of spectra, using a multi-channel version of the Burg algorithm. The order of the model is a user-defined parameter. These models are used to extrapolate each spectrum forward and backward. The extrapolating factor is a user-defined parameter. The super-resolved time-domain soundings for each channel are obtained by IFFT. Zero-padding can be used for time-domain interpolation (this process is purely aesthetic). Each spectrum's extrapolation factor is equal to the resolution enhancement factor after IFFT. The multi-channel version of the Burg algorithm used by the PBWE accounts for the targets' echoes information present in each polarimetric channel: the principle of this technique consists in extrapolating each polarimetric channel with a weighted sum of previous/next samples not only using this channel but also the others. For this reason, in the case where a target's scattering coefficients are different and non-zero for at least two polarimetric channels of the radar, we expect the PBWE to perform better than the BWE. The PyPBWE package contains the PyPBWE.PBWE function, allowing you to apply the PBWE directly to a given set of multi-polarimetric-channel radar spectra and get a super-resolved sounding per channel. This function calls several other functions from the package, that you can call independently if needed: PyPBWE.polar_burg: fits an AR model to each polarimetric channel of a spectrum, using a multi-channel version of the Burg algorithm. PyPBWE.polar_extrapolation: extrapolates forward, backward or both a multi-polarimetric-channel spectrum, given a set of AR models.","title":"Description"},{"location":"PyPBWE/#importation","text":"Once the library is installed, the PyPBWE package can simply be imported: import PyPBWE","title":"Importation"},{"location":"PyPBWE/#recommendations","text":"","title":"Recommendations"},{"location":"PyPBWE/#the-order-of-the-ar-model","text":"In theory, the ideal order of an AR model depends on the number of complex sine-waves composing the spectrum. However, in practical cases, a higher order is required to obtain good results in presence of noise. For the BWE, Cuomo (1992) recommends an order equal to \u2153 of the number of samples in the spectrum. This is also what we recommend for PBWE.","title":"The order of the AR model"},{"location":"PyPBWE/#the-extrapolation-factor","text":"In theory, a sum of sine-wave can be extrapolated infinitely. However, in practical cases, errors accumulate with the extrapolation. For the BWE, Cuomo (1992) recommends an extrapolation factor of maximum 3. Higher values can be tried for the PBWE, as the model is expected to be more robust, but the results must be interpreted cautiously.","title":"The extrapolation factor"},{"location":"PyPBWE/#the-effect-of-side-lobes","text":"In the case of a radar signal spectrum obtained by FFT, 2 effects must be mitigated before PBWE: If a window was applied to any signal channel, it must be inverted. The application of the FFT generates side-lobes effects on the borders of a spectrum. For this reason, Cuomo (1992) recommends to remove 5% of frequencies on each side of a spectrum before PBWE. The same goes for PBWE. In the case of a radar measuring only the real-part of each frequency spectrum, the imaginary part can be reconstructed by Hilbert transform. The FFT being part of Hilbert transform implementations, errors can also be expected on the border of reconstructed spectra. We thus also recommend to cut 5% of samples on each side of each polarimetric channel spectrum in this case. The PyPBWE.PBWE function allows you to remove 5% of samples on each side of a spectrum before PBWE.","title":"The effect of side-lobes"},{"location":"PyPBWE/#the-effect-of-distortions","text":"The PBWE technique is based on the assumption that a target response signal will be a complex sine-wave of the same frequency (but potentially different amplitudes) in all polarimetric channels of a radar. In many practical applications, a radar response signal can differ from this model, due to various distortion effects. Such distortions can make the application of the direct application of the PBWE impossible. We thus recommend to correct distortions prior to a PBWE application. Different solutions are possible for different sources of distortion: Effect of the antennas gain: No antenna can transmit all frequencies with the same gain. This will cause distortions of sine-waves in a radar spectrum. You can try to compensate for this effect with a calibration radar measurement on a \"perfect reflector\" (a metallic sphere or a large metallic plate). From the spectrum of the echo from such target, the antennas gain can be determined, and inverted in all other radar measurements. This process is sometimes called \"whitening\" and is described in Oudart et al. (2021). As different temperatures can lead to significantly different amplitudes over a radar's bandwidth, for a successful whitening process we recommend to apply first a temperature correction (as the one described in Herv\u00e9 et al. (2020)). If necessary, we recommend to apply this process for all polarimetric channels of the radar. Effect of the ionosphere: The ionosphere of any planet has a frequency-dependent attenuation effect on electromagnetic waves. This will cause distortions of sine-waves in a radar spectrum. This effect can be compensated using a ionospheric model. For instance Gambacorta et al. (2022) used a ionospheric Gamma model before applying the PBWE to MARSIS (Mars Express) soundings. If necessary, we recommend to apply this process for all polarimetric channels of the radar. Effect of subsurface attenuations: When a radar signal is transmitted through a sub-surface, it is affected by different frequency-dependent attenuations (absorption, scattering...). It can thus be expected that deeper echoes in a high-loss subsurface will not be correctly reconstructed by PBWE. We recommend to use the PySSBWE package, as the SSBWE (State-Space Bandwidth Extrapolation) technique accounts for such attenuations.","title":"The effect of distortions"},{"location":"PyPBWE/#the-effect-of-noise","text":"The presence of noise in a signal impact the quality of the AR model determined by the Burg algorithm. For this reason, a high level of noise will impact the BWE results (echoes amplitudes and time-delays), as demonstrated in Oudart et al. (2021). We expect this effect to be lower for the PBWE than for the BWE in the case of targets having different non-zero scattering coefficients in at least two polarimetric channels of the radar.","title":"The effect of noise"},{"location":"PyPBWE/#electromagnetic-interferences","text":"EM interferences can cause peaks in the measured radar spectrum. Such peaks will impair the AR modelling of the signal. The effect can be mitigated by detecting outliers in the spectrum, and then replacing them by interpolation, as proposed by Raguso et al. (2018). If necessary, we recommend to apply this process for all polarimetric channels of the radar using the multi-channel Burg algorithm and extrapolation.","title":"Electromagnetic interferences"},{"location":"PyPBWE/#cross-talk","text":"If the emission and reception antennas / channels are not the same, a cross-talk phenomenon can generate unwanted signals in the radar response. It is recommended to remove such effects prior to the application of the BWE. This can for instance be done by subtracting a \"free-space\" (without any targets) calibration signal to any radar response. We thus recommend to acquire a \"free-space\" measurement for each polarimetric channel of the radar, and to subtract it to any radar response coming from this channel.","title":"Cross-talk"},{"location":"PyPBWE/#functions","text":"","title":"Functions"},{"location":"PyPBWE/#pypbwepbwespec_matdfextra_factormodel_orderzp_factorside_cuttrue","text":"The PyPBWE.PBWE function applies the Polarimetric Bandwidth Extrapolation to a radar polarimetric channels spectra. Inputs: spec_mat: complex 2D array , each row containing the spectrum of a polarimetric channel to be extrapolated. df: float frequency step corresponding to spec_mat [Hz]. extra_factor: float factor between the extrapolated and the original spectra's bandwidths. model_order: float order of the AR models for extrapolation, expressed as a ratio of the original spectra's bandwidth. zp_factor: float factor between the zero-padded and original spectra's bandwidth. side_cut: (optional) boolean , 5% of samples are cut on each side of each spectra if True. Outputs: output_pbwe: complex 2D array , each row containing the time-domain radar signal of a polarimetric channel after PBWE. time_pbwe_vect: float 1D array containing the time axis corresponding to output_pbwe [s]. Notes: In this implementation, the time-domain output signal is scaled by the number of samples in each polarimetric channel's spectrum. A Hamming window is applied to each spectrum before IFFT.","title":"PyPBWE.PBWE(spec_mat,df,extra_factor,model_order,zp_factor,side_cut=True)"},{"location":"PyPBWE/#pypbwepolar_burgxp","text":"The PyPBWE.polar_burg function fits an AR model to each polarimetric channel's spectrum, using a multi-channel version of the Burg algorithm. Inputs: X: complex 2D array , each row containing the spectrum of a polarimetric channel to be modelled. p: integer order of the AR models. Outputs: Thetaf: complex 2D array containing the coefficients of the multi-channel AR forward model. Thetab: complex 2D array containing the coefficients of the multi-channel AR backward model. err: float 1D array of prediction errors (forward/backward).","title":"PyPBWE.polar_burg(X,p)"},{"location":"PyPBWE/#pypbwepolar_extrapolationxthetafthetabmextraextra_modeboth","text":"The PyPBWE.polar_extrapolation function extrapolates a set of polarimetric channel spectra given their multi-channel AR model, forward, backward or both. Inputs: X: complex 2D array , each row containing the spectrum of a polarimetric channel to be extrapolated. Thetaf: complex 2D array containing the coefficients of the multi-channel AR forward model. Thetab: complex 2D array containing the coefficients of the multi-channel AR backward model. Mextra: integer number of samples to be extrapolated forward, backward or both for each channel. extra_mode: (optional) string containing the extrapolation mode, \"forward\"/\"backward\"/\"both\". Outputs: X_extra: complex 2D array , each row containing the extrapolated spectrum of a polarimetric channel. X_forward: complex 2D array , each row containing the forward extrapolation of a polarimetric channel. X_backward: complex 2D array , each row containing the backward extrapolation of a polarimetric channel.","title":"PyPBWE.polar_extrapolation(X,Thetaf,Thetab,Mextra,extra_mode='both')"},{"location":"PyPBWE/#example","text":"2 example scripts are proposed with the same synthetic radar scenario for the PyBWE package: An application of PyPBWE.PBWE on a synthetic radar signal is proposed in examples/script_example_PyPBWE_PBWE.py . A manual use of PyPBWE.polar_burg and PyPBWE.polar_extrapolation on a synthetic radar signal is proposed in examples/script_example_PyPBWE_extrapolation.py . In the following, these 2 scripts are explained as a single tutorial:","title":"Example"},{"location":"PyPBWE/#presentation-of-the-scenario","text":"The synthetic radar signal example (inspired by the WISDOM GPR of the ExoMars rover mission, Ciarletti et al. (2017)): A SFCW (Stepped Frequency Continuous Wave) radar working between 0.5 and 3 GHz measures a 1001 frequencies spectrum when sounding. This radar can transmit and receive signals in two linear polarizations named 0 and 1. This leads to 4 polirization channels: 2 co-polar named 00 and 11 (emission and reception in the same polarization), and 2 cross-polar named 01 and 10 (emission and reception in different polarizations). For simplicity, we will only consider the co-polar channels 00 and 11 in this example. Only the In-phase component (real part of the spectrum) is measured, the Quadrature component (imaginary part of the spectrum) is reconstructed by Hilbert transform. Two targets in free-space are seperated by 5 cm, slightly below the radar's free-space resolution. These targets generate echoes of given complex amplitudes in the radar's signal, or complex sine-waves in the measured spectrum. The measured spectrum is corrupted by a white-noise of standard deviation 10X smaller than the complex sine-waves' amplitudes. The Polarimetric Bandwidth Extrapolation (PBWE) is applied to this radar's signal using the PyBWE function_PBWE: Most of the estimation errors when reconstructing a complex spectrum with the Hilbert transform are on the far sides of the spectrum. For this reason, we cut 5% of frequencies on each side of the spectrum before PBWE. We would do the same for a radar working in time-domain, as most errors in FFT estimation are also on each side of the multi-channel spectrum. This process is useless for a radar working in the frequency-domain and measuring both In-Phase and Quadrature components of the spectrum. We then fit an AR model to the multi-channel spectrum, with an order equal to \u2153 of the spectrum samples, as recommended by Cuomo (1992). We use this model to extrapolate the spectrum on each side, to obtain a bandwidth 3X larger (maximum extrapolation factor recommended by Cuomo (1992)). A bandwidth X3 yields a resolution X3 better in time-domain. The extrapolated multi-channel spectrum is eventually converted to a one time-domain signal per channel with IFFT, and zero-padding to interpolate the signal X10. This interpolation is purely aesthetic. This scenario requires the following libraries: import matplotlib.pyplot as plt import numpy as np from math import pi from scipy.signal import hilbert import PyPBWE","title":"Presentation of the scenario"},{"location":"PyPBWE/#the-synthetic-signal-generation","text":"In this section we describe how to generate analytically a synthetic radar sounding to test the PyPBWE package. Generate a vector of 1001 frequencies between 0.5 and 3 GHz: freq_vect = np.linspace ( 0 .5e9,3e9,1001 ) Distance (m) between two radar targets in free-space (returning two echoes) and the radar: dist_target1 = 1 dist_target2 = 1 .07 Amplitude associated with each target echo for each polarimetric channel: amp_target1_00 = 1 amp_target2_00 = 1 amp_target1_11 = 1 amp_target2_11 = -1 Generate a sum of two complex sine-waves corresponding to the targets' echoes (each with an amplitude of 1), for the 00 channel: spec_vect_00 = ( amp_target1_00*np.exp ( 1j*4*pi*dist_target1*freq_vect/3e8 )) + ( amp_target2_00*np.exp ( 1j*4*pi*dist_target2*freq_vect/3e8 )) Generate a sum of two complex sine-waves corresponding to the targets' echoes (with amplitudes of 1 and -1), for the 11 channel: spec_vect_11 = ( amp_target1_11*np.exp ( 1j*4*pi*dist_target1*freq_vect/3e8 )) + ( amp_target2_11*np.exp ( 1j*4*pi*dist_target2*freq_vect/3e8 )) Only keep the real part of the spectrum (In-phase component) for the 2 channels: spec_vect_00 = np.real ( spec_vect_00 ) spec_vect_11 = np.real ( spec_vect_11 ) Add a white noise (standard deviation 0.1) to each spectrum signal: wn_vect_00 = np.random.normal ( 0 ,0.1,spec_vect_00.shape ) wn_vect_11 = np.random.normal ( 0 ,0.1,spec_vect_11.shape ) spec_vect_00 += wn_vect_00 spec_vect_11 += wn_vect_11 Reconstruct a complex signal with the Hilbert transform for the 2 channels: spec_vect_00 = hilbert ( spec_vect_00 )[ ::2 ] spec_vect_11 = hilbert ( spec_vect_11 )[ ::2 ] freq_vect = freq_vect [ ::2 ] Assemble the 2 spectrum channels into a single matrix: spec_mat = np.vstack (( spec_vect_00,spec_vect_11 )) This is the matrix of signals to which we will apply the PBWE.","title":"The synthetic signal generation"},{"location":"PyPBWE/#the-application-of-the-pbwe","text":"The PBWE can be applied directly to the multi-channel spectrum using the PyPBWE.PBWE function. Extrapolation factor (=< 3 recommended by Cuomo (1992)): extra_factor = 3 Order of the model as a ratio of the total number of samples in each spectrum (= 0.33 recommended by Cuomo (1992)): model_order = 0 .33 Zero-padding factor (= time domain interpolation factor): zp_factor = 10 Cut 5% of samples on each side of the 2 spectra: side_cut = True Calculate the spectrum's frequency step: df = freq_vect [ 1 ] -freq_vect [ 0 ] Application of the PBWE to the 2 polarimetric channels' spectra: output_pbwe, time_pbwe_vect = PyPBWE.PBWE ( spec_mat,df,extra_factor,model_order,zp_factor,side_cut ) output_bwe matrix contains the time-domain radar soundings after PBWE, ready to be displayed with time axis time_pbwe_vect.","title":"The application of the PBWE:"},{"location":"PyPBWE/#display-of-the-pbwe-results","text":"In this section we display the PBWE results compared to the original radar soundings for polarimetric channels 00 and 11. Generate a time vector corresponding to the time-domain transform: time_vect = np.linspace ( 0 ,1/df,zp_factor*np.shape ( spec_mat )[ 1 ]) Display the original radar sounding and the PBWE version for channel 00: plt.figure ( figsize =( 12 .75,5 )) plt.subplot ( 1 ,2,1 ) plt.plot ( time_vect*1e9,abs ( 1 .85*np.fft.fft ( spec_mat [ 0 ,: ] *np.hamming ( len ( spec_mat [ 0 ,: ])) ,zp_factor*len ( spec_mat [ 0 ,: ]))) /len ( spec_mat [ 0 ,: ]) , 'k-' ) plt.plot ( time_pbwe_vect*1e9,abs ( output_pbwe [ 0 ,: ]) , 'r-' ) plt.xlim ([ 5 ,9 ]) plt.ylim ([ -0.05,1.3 ]) plt.xlabel ( 'Time delays (ns)' ) plt.ylabel ( 'Normalized amplitude' ) plt.legend ([ 'Original radar sounding' , 'Radar sounding after PBWE' ] , loc = 'best' ) plt.title ( 'PBWE application - Polar channel 00' ) plt.grid () Display the original radar sounding and the PBWE version for channel 00: plt.subplot ( 1 ,2,2 ) plt.plot ( time_vect*1e9,abs ( 1 .85*np.fft.fft ( spec_mat [ 1 ,: ] *np.hamming ( len ( spec_mat [ 1 ,: ])) ,zp_factor*len ( spec_mat [ 1 ,: ]))) /len ( spec_mat [ 1 ,: ]) , 'k-' ) plt.plot ( time_pbwe_vect*1e9,abs ( output_pbwe [ 1 ,: ]) , 'r-' ) plt.xlim ([ 5 ,9 ]) plt.ylim ([ -0.05,1.3 ]) plt.xlabel ( 'Time delays (ns)' ) plt.ylabel ( 'Normalized amplitude' ) plt.legend ([ 'Original radar sounding' , 'Radar sounding after PBWE' ] , loc = 'best' ) plt.title ( 'PBWE application - Polar channel 11' ) plt.grid () plt.tight_layout () plt.show () (The X 1.85 factor in amplitude corresponds to the compensation for the Hamming window). Here is an example of figure displayed with this command:","title":"Display of the PBWE results:"},{"location":"PyPBWE/#manual-extrapolation","text":"If you want to model and extrapolate the multi-channel spectrum manually, it can also be done using the PyPBWE.polar_burg and PyPBWE.polar_extrapolation functions. Cutting 5% of frequencies on each side of the spectrum: spec_mat = spec_mat [ :,round ( np.shape ( spec_mat )[ 1 ] *0.05 ) :np.shape ( spec_mat )[ 1 ] -round ( np.shape ( spec_mat )[ 1 ] *0.05 )] freq_vect = freq_vect [ round ( len ( freq_vect ) *0.05 ) :len ( freq_vect ) -round ( len ( freq_vect ) *0.05 )] Retrieve the number of polarimetric channels: Npol = np.shape ( spec_mat )[ 0 ] Retrieve the new number of samples in the spectrum: M = np.shape ( spec_mat )[ 1 ] Set the multichannel AR model's order as \u2153 of the number of samples: model_order_nb = round ( 0 .33*M ) Fit a multichannel AR model to spec_mat: [ Thetaf,Thetab,err ] = PyPBWE.polar_burg ( spec_mat,model_order_nb ) Number of samples to be extrapolated on each side of the multichannel spectrum to get an extrapolation factor of 3: Mextra = round ((( 3 *M ) -M ) //2 ) +1 Extrapolation of spec_mat on each side of the multichannel spectrum: spec_mat_extra,spec_mat_extra_forward,spec_mat_extra_backward = PyPBWE.polar_extrapolation ( spec_mat,Thetaf,Thetab,Mextra, \"both\" ) spec_mat_extra is the extrapolated multichannel spectrum on both sides, spec_mat_extra_forward and spec_mat_extra_backward are the forward and backward extrapolations of this multichannel spectrum.","title":"Manual extrapolation:"},{"location":"PyPBWE/#display-of-the-extrapolation-result","text":"In this section, we display the polarimetric extrapolated spectra (channels 00 and 11), along with the expected spectra (noise-free) after extrapolation for comparison. Generate the expected spectrum after extrapolation for comparison: df = freq_vect [ 1 ] -freq_vect [ 0 ] freq_vect_expected = np.linspace ( freq_vect [ 0 ] - ( df* ( Mextra-2 )) ,freq_vect [ -1 ] + ( df*Mextra ) ,M+ ( Mextra*2 )) spec_vect_expected_00 = np.exp ( 1j*4*pi*dist_target1*freq_vect_expected/3e8 ) +np.exp ( 1j*4*pi*dist_target2*freq_vect_expected/3e8 ) spec_vect_expected_11 = np.exp ( 1j*4*pi*dist_target1*freq_vect_expected/3e8 ) -np.exp ( 1j*4*pi*dist_target2*freq_vect_expected/3e8 ) Display the expected spectrum after extrapolation for the 00 and 11 channels: plt.figure ( figsize =( 10 ,6 )) plt.subplot ( 2 ,1,1 ) plt.plot ( freq_vect_expected*1e-9,np.real ( spec_vect_expected_00 ) , 'r-' ) plt.plot ( freq_vect_expected*1e-9,abs ( spec_vect_expected_00 ) , 'k-' ) plt.axvspan (( freq_vect [ 0 ] - ( df* ( Mextra-2 ))) *1e-9, ( freq_vect [ 0 ] -df ) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.axvspan (( freq_vect [ -1 ] +df ) *1e-9, ( freq_vect [ -1 ] + ( df*Mextra )) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Mextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Mextra )) *1e-9 ]) plt.ylim ([ -2.5,3 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Real part' , 'Modulus' ] ,loc = 'upper left' ,ncol = 2 ) plt.title ( 'Expected spectrum after extrapolation - Polar channel 00' ) plt.grid () plt.subplot ( 2 ,1,2 ) plt.plot ( freq_vect_expected*1e-9,np.real ( spec_vect_expected_11 ) , 'r-' ) plt.plot ( freq_vect_expected*1e-9,abs ( spec_vect_expected_11 ) , 'k-' ) plt.axvspan (( freq_vect [ 0 ] - ( df* ( Mextra-2 ))) *1e-9, ( freq_vect [ 0 ] -df ) *1e-9,facecolor = 'k' ,alpha = 0 .1 ) plt.axvspan (( freq_vect [ -1 ] +df ) *1e-9, ( freq_vect [ -1 ] + ( df*Mextra )) *1e-9,facecolor = 'k' ,alpha = 0 .1 ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Mextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Mextra )) *1e-9 ]) plt.ylim ([ -2.5,3 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Real part' , 'Modulus' ] ,loc = 'upper left' ,ncol = 2 ) plt.title ( 'Expected spectrum after extrapolation - Polar channel 11' ) plt.grid () plt.tight_layout () plt.show () Here is an example of figure displayed with this command: Generate a vector of frequencies for the forward and backward extrapolations: freq_vect_forward = np.linspace ( freq_vect [ -1 ] +df,freq_vect [ -1 ] + ( df*Mextra ) ,Mextra ) freq_vect_backward = np.linspace ( freq_vect [ 0 ] - ( df* ( Mextra-2 )) ,freq_vect [ 0 ] -df,Mextra ) Display the original radar spectrum and the extrapolation for the 00 and 11 channels: plt.figure ( figsize =( 11 ,6 )) plt.subplot ( 2 ,1,1 ) plt.plot ( freq_vect*1e-9,np.real ( spec_mat [ 0 ,: ]) , 'r-' ) plt.plot ( freq_vect*1e-9,abs ( spec_mat [ 0 ,: ]) , 'k-' ) plt.plot ( freq_vect_backward*1e-9,np.real ( spec_mat_extra_backward [ 0 ,: ]) , 'y-' ) plt.plot ( freq_vect_backward*1e-9,abs ( spec_mat_extra_backward [ 0 ,: ]) , 'g-' ) plt.plot ( freq_vect_forward*1e-9,np.real ( spec_mat_extra_forward [ 0 ,: ]) , 'c-' ) plt.plot ( freq_vect_forward*1e-9,abs ( spec_mat_extra_forward [ 0 ,: ]) , 'b-' ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Mextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Mextra )) *1e-9 ]) plt.ylim ([ -3.6,2.3 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Original radar spectrum (real part)' , 'Original radar spectrum (modulus)' , 'Backward extrapolation (real part)' , 'Backward extrapolation (modulus)' , 'Forward extrapolation (real part)' , 'Forward extrapolation (modulus)' ] ,loc = 'lower center' ,ncol = 3 ) plt.title ( 'Spectrum polarimetric extrapolation - Polar channel 00' ) plt.grid () plt.subplot ( 2 ,1,2 ) plt.plot ( freq_vect*1e-9,np.real ( spec_mat [ 1 ,: ]) , 'r-' ) plt.plot ( freq_vect*1e-9,abs ( spec_mat [ 1 ,: ]) , 'k-' ) plt.plot ( freq_vect_backward*1e-9,np.real ( spec_mat_extra_backward [ 1 ,: ]) , 'y-' ) plt.plot ( freq_vect_backward*1e-9,abs ( spec_mat_extra_backward [ 1 ,: ]) , 'g-' ) plt.plot ( freq_vect_forward*1e-9,np.real ( spec_mat_extra_forward [ 1 ,: ]) , 'c-' ) plt.plot ( freq_vect_forward*1e-9,abs ( spec_mat_extra_forward [ 1 ,: ]) , 'b-' ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Mextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Mextra )) *1e-9 ]) plt.ylim ([ -3.6,2.3 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Original radar spectrum (real part)' , 'Original radar spectrum (modulus)' , 'Backward extrapolation (real part)' , 'Backward extrapolation (modulus)' , 'Forward extrapolation (real part)' , 'Forward extrapolation (modulus)' ] ,loc = 'lower center' ,ncol = 3 ) plt.title ( 'Spectrum polarimetric extrapolation - Polar channel 11' ) plt.grid () plt.tight_layout () plt.show () Here is an example of figure displayed with this command:","title":"Display of the extrapolation result:"},{"location":"PyPBWE/#references","text":"Cuomo (1992) Suwa and Iwamoto (2003) Suwa and Iwamoto (2007) Ciarletti et al. (2017) Raguso et al. (2018) Herv\u00e9 et al. (2020) Oudart et al. (2021) Gambacorta et al. (2022)","title":"References"},{"location":"PySSBWE/","text":"PySSBWE package Description The PySSBWE package is an \"advanced\" package of this library. It allows you to apply the State-Space Bandwidth Extrapolation (SSBWE) technique as defined by Piou (1999) to any to any radar spectrum. The SSBWE is a super-resolution technique, as it yields a better range resolution in time-domain than classic spectral estimation techniques (FFT). It is a state-space modelling version of the classic Bandwidth Extrapolation (BWE), this improved model making the technique more robust to noise and sub-surface attenuations. The SSBWE works this way: The input is the frequency-domain spectrum of the radar's reponse signal from a series of targets, with sub-surface attenuations. In this situation, the signal should in theory be a sum of complex sine-waves, with distortions following decreasing exponentials. A state-space model is fitted to this spectrum, using a state-space identification technique. The order of the model is estimated by Akaike's Information Criterion (AIC). One model is used to extrapolate the spectrum forward, and another to extrapolate the spectrum backward. The extrapolating factor is a user-defined parameter. The super-resolved time-domain sounding is obtained by IFFT. Zero-padding can be used for time-domain interpolation (this process is purely aesthetic). The spectrum's extrapolation factor is equal to the resolution enhancement factor after IFFT. The PySSBWE package contains the PySSBWE.SSBWE function, allowing you to apply the SSBWE directly to a given radar spectrum and get a super-resolved sounding. This function calls several other functions from the package, that you can call independently if needed: PySSBWE.statespace_model: fits a state-space model to a spectrum, using 2 state-space identification methods. PySSBWE.AIC: estimates the ideal order for a spectrum's state-space model using Akaike's Information Criterion. PySSBWE.MDL: estimates the ideal order for a spectrum's state-space model using the Minimum Description Length criterion. PySSBWE.two_line_fit: estimates the ideal order for a spectrum's state-space model using the \"two-line fit\" method. PySSBWE.statespace_extrapolation: extrapolates forward, backward or both a spectrum, given an AR model. In addition, this package also contains a function that can be used to retrieve information on the different targets' echoes from a spectrum's state-space model: PySSBWE.statespace_properties: retrieve the amplitudes, time-delays, and frequency-decays estimations of each echoes from a spectrum's state-space model. Importation Once the library is installed, the PySSBWE package can simply be imported: import PySSBWE Recommendations The order of the AR model The idea behind the state-space identification of the SSBWE technique is to seperate the singular values of signal from the singular values of noise in the input spectrum's Hankel matrix. The ideal order of a state-space model corresponds to the number of selected singular values being part of the signal sub-space. It is directly the number of complex sine-waves composing the spectrum, also equal to the number of targets sounded by the radar. If you have an a priori knowledge of the number of targets, you directly set the order of the model. If not, you can estimate it with Akaike's Information Criterion (AIC, see Akaike (1974)), implemented in PySSBWE, as recommended by Piou (1999). Other criteria are also available. The stability of the model not being guaranteed in the case of the SSBWE, a wrong estimation of the ideal model order can lead to diverging extrapolations, and thus to very high errors in time-domain. The extrapolation factor In theory, a sum of sine-wave can be extrapolated infinitely. However, in practical cases, errors accumulate with the extrapolation. For the BWE, Cuomo (1992) recommends an extrapolation factor of maximum 3. This is also the extrapolation factor used by Piou for the SSBWE (1999). The effect of side-lobes In the case of a radar signal spectrum obtained by FFT, 2 effects must be mitigated before SSBWE: If a window was applied to the signal, it must be inverted. The application of the FFT generates side-lobes effects on the borders of the spectrum. For this reason, Cuomo (1992) recommends to remove 5% of frequencies on each side of a spectrum before SSBWE. The same goes for SSBWE. In the case of a radar measuring only the real-part of a frequency spectrum, the imaginary part can be reconstructed by Hilbert transform. The FFT being part of Hilbert transform implementations, errors can also be expected on the border of the spectrum. We thus also recommend to cut 5% of samples on each side of a spectrum in this case. The PySSBWE.SSBWE function allows you to remove 5% of samples on each side of a spectrum before SSBWE. The effect of distortions The SSBWE technique is based on the assumption that the spectrum of a radar response signal from targets is a sum of complex sine-waves, with only decreasing exponential distortions. In many practical applications, a radar response signal can differ from this model, due to various distortion effects. Such distortions can make the application of the direct application of the BWE impossible. We thus recommend to correct distortions prior to a SSBWE application. Different solutions are possible for different sources of distortion: Effect of the antennas gain: No antenna can transmit all frequencies with the same gain. This will cause distortions of sine-waves in a radar spectrum. You can try to compensate for this effect with a calibration radar measurement on a \"perfect reflector\" (a metallic sphere or a large metallic plate). From the spectrum of the echo from such target, the antennas gain can be determined, and inverted in all other radar measurements. This process is sometimes called \"whitening\" and is described in Oudart et al. (2021). As different temperatures can lead to significantly different amplitudes over a radar's bandwidth, for a successful whitening process we recommend to apply first a temperature correction (as the one described in Herv\u00e9 et al. (2020)). Effect of the ionosphere: The ionosphere of any planet has a frequency-dependent attenuation effect on electromagnetic waves. This will cause distortions of sine-waves in a radar spectrum. This effect can be compensated using a ionospheric model. For instance Gambacorta et al. (2022) used a ionospheric Gamma model before applying the SSBWE to MARSIS (Mars Express) soundings. Effect of subsurface attenuations: When a radar signal is transmitted through a sub-surface, it is affected by different frequency-dependent attenuations (absorption, scattering...). It can thus be expected that deeper echoes in a high-loss subsurface will not be correctly reconstructed by the classic BWE. The SSBWE accounts for this distortion effect, and the estimation of the level of attenuations at each target (the sum of absorption, scattering...) can even be extracted from the model. The effect of noise The presence of noise in a signal impact the quality of the AR model determined by the Burg algorithm. For this reason, a high level of noise will impact the classic BWE results (echoes amplitudes and time-delays), as demonstrated in Oudart et al. (2021). The state-space model used by the SSBWE has a more robust noise model, and if the order of the model is chosen well, noise will impact much less the SSBWE than the BWE. Electromagnetic interferences EM interferences can cause peaks in the measured radar spectrum. Such peaks will impair the AR modelling of the signal. The effect can be mitigated by detecting outliers in the spectrum, and then replacing them by interpolation, as proposed by Raguso et al. (2018). Cross-talk If the emission and reception antennas / channels are not the same, a cross-talk phenomenon can generate unwanted signals in the radar response. It is recommended to remove such effects prior to the application of the SSBWE. This can for instance be done by subtracting a \"free-space\" (without any targets) calibration signal to any radar response. Functions PySSBWE.AIC(sv,N) The PySSBWE.AIC function estimates the ideal state-space model order from the spectrum's Hankel matrix singular values, using AIC. See Akaike (1974) and Wax & Kailath (1985). This order corresponds to the number of singular values selected as being part of the signal's subspace, and is ideally equal to the number of target echoes in the radar signal. Inputs: sv: float 1D array of the spectrum's Hankel matrix singular values, in decreasing order. N: integer number of samples in the spectrum. Outputs: output_order: integer ideal state-space model order according to AIC. PySSBWE.MDL(sv,N) The PySSBWE.MDL function estimates the ideal state-space model order from the spectrum's Hankel matrix singular values, using MDL. See Wax & Kailath (1985). This order corresponds to the number of singular values selected as being part of the signal's subspace, and is ideally equal to the number of target echoes in the radar signal. Inputs: sv: float 1D array of the spectrum's Hankel matrix singular values, in decreasing order. N: integer number of samples in the spectrum. Outputs: output_order: integer ideal state-space model order according to MDL. PySSBWE.SSBWE(spec,df,extra_factor,zp_factor,side_cut=True,order=0,criterion='aic') The PySSBWE.SSBWE function applies the State-Space Bandwidth Extrapolation (SSBWE) to a radar signal's spectrum. The State-Space model is estimated using two methods: Method 1: estimation of the state-space model from the observability matrix. Method 2: estimation of the state-space model from the controllability matrix. Both models' results are returned by the function. Inputs: spec: complex 1D array containing the spectrum to which the SSBWE will be applied. df: float frequency step corresponding to spec [Hz]. extra_factor: float factor between the extrapolated and the original spectrum's bandwidths. zp_factor: float factor between the zero-padded and original spectrum's bandwidth. side_cut: (optional) boolean , 5% of samples are cut on each side of the spectrum if True. order: (optional) integer order of the state-space model (number of selected singular value, ideally equal to the number of radar targets), if = 0 the order is estimated by the selected criterion (AIC by default). criterion: (optional) string name of the method / criterion to use for the order estimation if order = 0 ('aic' = Akaike's Information Criterion / 'mdl' = Minimum Description Length / 'two_line_fit' = two-line fit approach). Outputs: output_ssbwe_1: complex 1D array extrapolated spectrum using SSBWE method 1. output_ssbwe_2: complex 1D array extrapolated spectrum using SSBWE method 2. time_ssbwe_vect: complex 1D array time axis corresponding to output_ssbwe_1 and output_ssbwe_2 [s]. Notes: Unlike the classic BWE (or the PBWE), where the Burg algorithm guaranties the stability of the model, the stability of the state-space model is not guaranteed. The order of the model is by default estimated using AIC. It can also be set by the user, or estimated with another method. PySSBWE.statespace_extrapolation(y,A,B,C,Nextra) The PySSBWE.statespace_extrapolation function extrapolates forward a spectrum given its state-space model. Inputs: y: complex 1D array containing the spectrum to be extrapolated. A: complex 2D array containing the state-space model's \"state matrix\". B: complex 1D array containing the state-space model's \"input matrix\". C: complex 1D array containing the state-space model's \"output matrix\". Nextra: integer number of samples to extrapolate from y. Outputs: y_extra: complex 1D array containing the forward extrapolation of y. Notes: This function only extrapolates a spectrum forward. To extrapolate a spectrum backward, you must flip the spectrum, fit a state-space model to it, extrapolate it forward, and eventually flip it again. PySSBWE.statespace_model(y,order=0,criterion='aic') The PySSBWE.statespace_model function fits a state-space model to a spectrum. The State-Space model is estimated using two methods: Method 1: estimation of the state-space model from the observability matrix. Method 2: estimation of the state-space model from the controllability matrix. Both models are returned by the function. Inputs: y: complex 1D array containing the spectrum to be modelled. order: (optional) integer order of the state-space model (number of selected singular value, ideally equal to the number of radar targets), if = 0 the order is estimated by the selected criterion (AIC by default). criterion: (optional) string name of the method / criterion to use for the order estimation if order = 0 ('aic' = Akaike's Information Criterion / 'mdl' = Minimum Description Length / 'two_line_fit' = two-line fit approach). Outputs: A1: complex 2D array containing the state-space model's \"state matrix\" obtained with method 1. B1: complex 2D array containing the state-space model's \"input matrix\" obtained with method 1. C1: complex 2D array containing the state-space model's \"output matrix\" obtained with method 1. A2: complex 2D array containing the state-space model's \"state matrix\" obtained with method 2. B2: complex 2D array containing the state-space model's \"input matrix\" obtained with method 2. C2: complex 2D array containing the state-space model's \"output matrix\" obtained with method 2. Notes: Unlike the Burg algorithm which guaranties the stability of the model, the stability of the state-space model is not guaranteed. The order of the model is by default estimated using AIC. It can also be set by the user, or estimated with another method. PySSBWE.statespace_properties(A,B,C,df,f1) The PySSBWE.statespace_properties function retrieves the different echoes properties (complex amplitudes, time-delays, frequency-decays) from a spectrum's state-space model. Inputs: A: complex 2D array containing the spectrum state-space model's \"state matrix\". B: complex 1D array containing the spectrum state-space model's \"input matrix\". C: complex 1D array containing the spectrum state-space model's \"output matrix\". df: float frequency step of the modelled spectrum [Hz]. f1: float 1 st frequency of the modelled spectrum [Hz]. Outputs: amp: complex 1D array containing the estimated echoes complex amplitudes in the signal. td: float 1D array containing the estimated echoes time-delays [s]. dec: float_1D_array containing the estimated echoes frequency-decay [1/Hz]. PySSBWE.two_line_fit(sv) The PySSBWE.two_line_fit function estimates the ideal state-space model order from the spectrum's Hankel matrix singular values, using a \"two-line fit\" approach. See Brindise & Vlachos (2017). This order corresponds to the number of singular values selected as being part of the signal's subspace, and is ideally equal to the number of target echoes in the radar signal. Inputs: sv: float 1D array of the spectrum's Hankel matrix singular values, in decreasing order. Outputs: output_order: integer ideal state-space model order according to the \"two-line fit\" approach. Example 2 example scripts are proposed with the same synthetic radar scenario for the PySSBWE package: An application of PySSBWE.SSBWE and PySSBWE.statespace_properties on a synthetic radar signal is proposed in examples/script_example_PySSBWE_SSBWE.py . A manual use of PySSBWE.statespace_model and PySSBWE.statespace_extrapolation on a synthetic radar signal is proposed in examples/script_example_PySSBWE_extrapolation.py . In the following, these 2 scripts are explained as a single tutorial: Presentation of the scenario The synthetic radar signal example (inspired by the WISDOM GPR of the ExoMars rover mission, Ciarletti et al. (2017)): A SFCW (Stepped Frequency Continuous Wave) radar working between 0.5 and 3 GHz measures a 1001 frequencies spectrum when sounding. Only the In-phase component (real part of the spectrum) is measured, the Quadrature component (imaginary part of the spectrum) is reconstructed by Hilbert transform. Two targets in free-space are seperated by 5 cm, slightly below the radar's free-space resolution. With these targets' echoes (or complex sine waves in frequency domain) are associated different complex amplitudes and different decays in frequency-domain. The measured spectrum is corrupted by a white-noise of standard deviation 10X smaller than the complex sine-waves' amplitudes. The State-Space Bandwidth Extrapolation (SSBWE) is applied to this radar's signal using the PyBWE function_SSBWE: Most of the estimation errors when reconstructing a complex spectrum with the Hilbert transform are on the far sides of the spectrum. For this reason, we cut 5% of frequencies on each side of the spectrum before SSBWE. We would do the same for a radar working in time-domain, as most errors in FFT estimation are also on each side of the spectrum. This process is useless for a radar working in the frequency-domain and measuring both In-Phase and Quadrature components of the spectrum. We then fit a state-space model to the spectrum, first in the forward and then the backward directions. We use these 2 models to extrapolate the spectrum on each side, to obtain a bandwidth 3X larger (maximum extrapolation factor recommended by Cuomo (1992)). A bandwidth X3 yields a resolution X3 better in time-domain. The extrapolated spectrum is eventually converted to a time-domain signal by IFFT, with zero-padding to interpolate the signal X10. This interpolation is purely aesthetic. From the state-space model of the spectrum, the properties of each echo (amplitude, time-delay, frequency-domain decay) can be estimated. This is done in the last part of this example. In the following example the order of the model (= number of echoes) is estimated using AIC. Other criteria can be selected. The order can also be forced by the user in the PySSBWE functions statespace_model and SSBWE with an optional parameter \"order\" if the number of echoes is known. 2 methods can be used to fit a state-space model to a spectrum: *Method 1: using the observability matrix. *Method 2: using the controllability matrix. This scenario requires the following libraries: import matplotlib.pyplot as plt import numpy as np from math import pi from scipy.signal import hilbert import PySSBWE The synthetic signal generation In this section we describe how to generate analytically a synthetic radar sounding to test the PySSBWE package. Generate a vector of 1001 frequencies between 0.5 and 3 GHz: freq_vect = np.linspace ( 0 .5e9,3e9,1001 ) Distance (m) between two radar targets in free-space (returning two echoes) and the radar: dist_target1 = 1 dist_target2 = 1 .07 Amplitude associated with each target echo: ampli_target1 = 1 ampli_target2 = 0 .75 Frequency decay associated with each target echo (1/Hz): decay_target1 = 0 .25e-9 decay_target2 = 0 .5e-9 Generate a sum of two complex sine-waves corresponding to the targets' echoes (each with an amplitude of 1): spec_vect = ( ampli_target1*np.exp (( -decay_target1+ ( 1j*4*pi*dist_target1/3e8 )) *freq_vect )) + ( ampli_target2*np.exp (( -decay_target2+ ( 1j*4*pi*dist_target2/3e8 )) *freq_vect )) Only keep the real part of the spectrum (In-phase component): spec_vect = np.real ( spec_vect ) Add a white noise (standard deviation 0.1) to this spectrum signal: wn_vect = np.random.normal ( 0 ,0.1,spec_vect.shape ) spec_vect += wn_vect Reconstruct a complex signal with the Hilbert transform: spec_vect = hilbert ( spec_vect )[ ::2 ] freq_vect = freq_vect [ ::2 ] This is the signal to which we will apply the SSBWE. The application of the SSBWE: The SSBWE can be applied directly to the spectrum using the PySSBWE.SSBWE function. Extrapolation factor (=< 3 recommended by Cuomo (1992)): extra_factor = 3 Zero-padding factor (= time domain interpolation factor): zp_factor = 10 Cut 5% of samples on each side of the spectrum: side_cut = True Calculate the spectrum's frequency step: df = freq_vect [ 1 ] -freq_vect [ 0 ] Application of the BWE to the spectrum: output_ssbwe_1, output_ssbwe_2, time_ssbwe_vect = PySSBWE.SSBWE ( spec_vect,df,extra_factor,zp_factor,side_cut ) output_ssbwe_1 and output_ssbwe_2 contains the time-domain radar soundings after SSBWE (method 1 and 2), ready to be displayed with time axis time_ssbwe_vect. Display of the SSBWE results: In this section we display the SSBWE results compared to the original radar sounding, for methods 1 and 2. Generate a time vector corresponding to the time-domain transform: time_vect = np.linspace ( 0 ,1/df,zp_factor*len ( spec_vect )) Display the original radar sounding and the SSBWE version using method 1: plt.figure ( figsize =( 10 ,5 )) plt.plot ( time_vect*1e9,abs ( 1 .85*np.fft.fft ( spec_vect*np.hamming ( len ( spec_vect )) ,zp_factor*len ( spec_vect ))) /len ( spec_vect ) , 'k-' ) plt.plot ( time_ssbwe_vect*1e9,abs ( output_ssbwe_1 ) , 'r-' ) plt.xlim ([ 5 ,9 ]) plt.ylim ([ -0.05,0.7 ]) plt.xlabel ( 'Time delays (ns)' ) plt.ylabel ( 'Normalized amplitude' ) plt.legend ([ 'Original radar sounding' , 'Radar sounding after SSBWE' ] ,loc = 'upper right' ) plt.title ( 'SSBWE application - method 1 (using the observability matrix)' ) plt.grid () plt.tight_layout () plt.show () Display the original radar sounding and the SSBWE version using method 2: plt.figure ( figsize =( 10 ,5 )) plt.plot ( time_vect*1e9,abs ( 1 .85*np.fft.fft ( spec_vect*np.hamming ( len ( spec_vect )) ,zp_factor*len ( spec_vect ))) /len ( spec_vect ) , 'k-' ) plt.plot ( time_ssbwe_vect*1e9,abs ( output_ssbwe_2 ) , 'r-' ) plt.xlim ([ 5 ,9 ]) plt.ylim ([ -0.05,0.7 ]) plt.xlabel ( 'Time delays (ns)' ) plt.ylabel ( 'Normalized amplitude' ) plt.legend ([ 'Original radar sounding' , 'Radar sounding after SSBWE' ] ,loc = 'upper right' ) plt.title ( 'SSBWE application - method 2 (using the controllability matrix)' ) plt.grid () plt.tight_layout () plt.show () (The X 1.85 factor in amplitude corresponds to the compensation for the Hamming window). Here is an example of figure displayed with this command for method 1: Extraction of the echoes properties: In this section we show how to extract the echoes properties (amplitudes, time-delays, frequency-domain decays) from a spectrum's state-space model. Manually cut 5% of frequencies of each side of the spectrum: spec_vect_cut = spec_vect [ round ( len ( spec_vect ) *0.05 ) :len ( spec_vect ) -round ( len ( spec_vect ) *0.05 )] freq_vect_cut = freq_vect [ round ( len ( freq_vect ) *0.05 ) :len ( freq_vect ) -round ( len ( freq_vect ) *0.05 )] Fit a state-space model to the spectrum: [ A1,B1,C1,A2,B2,C2 ] = PySSBWE.statespace_model ( spec_vect_cut ) Retrieve the spectrum's frequency step and 1 st frequency: df = freq_vect_cut [ 1 ] -freq_vect_cut [ 0 ] f1 = freq_vect_cut [ 0 ] Extract the echoes properties from the state-space model obtained with method 1: [ amp_1,td_1,dec_1 ] = PySSBWE.statespace_properties ( A1,B1,C1,df,f1 ) Extract the echoes properties from the state-space model obtained with method 2: [ amp_2,td_2,dec_2 ] = PySSBWE.statespace_properties ( A2,B2,C2,df,f1 ) Print the echoes amplitudes (module), range (m) and frequency decays (1/GHz) obtained using method 1: print ( \"---Echoes properties estimation (method 1: using observability matrix)---\" ) print ( \"Module amplitude of echoes: \" +str ( abs ( amp_1 ))) print ( \"Distance of targets from the radar (m): \" +str ( 0 .5*td_1*3e8 )) print ( \"Frequency-domain decay of echoes (1/GHz): \" +str ( dec_1*1e9 )) print ( \"-------------------------------------------------------------------------\" ) Print the echoes amplitudes (module), range (m) and frequency decays (1/GHz) obtained using method 2: print ( \"---Echoes properties estimation (method 2: using controllability matrix)---\" ) print ( \"Module amplitude of echoes: \" +str ( abs ( amp_2 ))) print ( \"Distance of targets from the radar (m): \" +str ( 0 .5*td_2*3e8 )) print ( \"Frequency-domain decay of echoes (1/GHz): \" +str ( dec_2*1e9 )) print ( \"---------------------------------------------------------------------------\" ) Manual extrapolation: If you want to model and extrapolate the spectrum manually, it can also be done using the PySSBWE.statespace_model and PySSBWE.statespace_extrapolation functions. Cutting 5% of frequencies on each side of the spectrum: spec_vect = spec_vect [ round ( len ( spec_vect ) *0.05 ) :len ( spec_vect ) -round ( len ( spec_vect ) *0.05 )] freq_vect = freq_vect [ round ( len ( freq_vect ) *0.05 ) :len ( freq_vect ) -round ( len ( freq_vect ) *0.05 )] Flip for a backward version of the spectrum: spec_vect_b = np.flip ( spec_vect ) Retrieve the numbers of samples in the spectrum: N = len ( spec_vect ) Number of samples to be extrapolated on each side of the spectrum to get an extrapolation factor of 3: Nextra = round ((( 3 *N ) -N ) //2 ) +1 Fit a state-space model to the spectrum for forward extrapolation: [ A1_f,B1_f,C1_f,A2_f,B2_f,C2_f ] = PySSBWE.statespace_model ( spec_vect ) Fit a state-space model to the flipped spectrum for backward extrapolation: [ A1_b,B1_b,C1_b,A2_b,B2_b,C2_b ] = PySSBWE.statespace_model ( spec_vect_b ) Forward extrapolation of the spectrum (obtained with method 1 and 2): spec_vect_extra_1_f = PySSBWE.statespace_extrapolation ( spec_vect,A1_f,B1_f,C1_f,Nextra ) spec_vect_extra_2_f = PySSBWE.statespace_extrapolation ( spec_vect,A2_f,B2_f,C2_f,Nextra ) Backward extrapolation of the spectrum (obtained with method 1 and 2): spec_vect_extra_1_b = PySSBWE.statespace_extrapolation ( spec_vect_b,A1_b,B1_b,C1_b,Nextra ) spec_vect_extra_2_b = PySSBWE.statespace_extrapolation ( spec_vect_b,A2_b,B2_b,C2_b,Nextra ) Flip the backward extrapolation (obtained with method 1 and 2): spec_vect_extra_1_b = np.flip ( spec_vect_extra_1_b ) spec_vect_extra_2_b = np.flip ( spec_vect_extra_2_b ) spec_vect_extra_1_f and spec_vect_extra_1_b are the forward and backward spectrum extrapolations using method 1. spec_vect_extra_2_f and spec_vect_extra_2_b are the forward and backward spectrum extrapolations using method 2. Display of the extrapolation result: In this section, we display the state-space extrapolated spectra (methods 1 and 2), along with the expected spectra (noise-free) after extrapolation for comparison. Generate the expected spectrum after extrapolation for comparison: df = freq_vect [ 1 ] -freq_vect [ 0 ] freq_vect_expected = np.linspace ( freq_vect [ 0 ] - ( df* ( Nextra-2 )) ,freq_vect [ -1 ] + ( df*Nextra ) ,N+ ( Nextra*2 )) spec_vect_expected = ( ampli_target1*np.exp (( -decay_target1+ ( 1j*4*pi*dist_target1/3e8 )) *freq_vect_expected )) + ( ampli_target2*np.exp (( -decay_target2+ ( 1j*4*pi*dist_target2/3e8 )) *freq_vect_expected )) Display the expected spectrum after extrapolation: plt.figure ( figsize =( 10 ,5 )) plt.plot ( freq_vect_expected*1e-9,np.real ( spec_vect_expected ) , 'r-' ) plt.plot ( freq_vect_expected*1e-9,abs ( spec_vect_expected ) , 'k-' ) plt.axvspan (( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ 0 ] -df ) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.axvspan (( freq_vect [ -1 ] +df ) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9 ]) plt.ylim ([ -2.5,2.5 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Real part' , 'Modulus' ] , loc = 'upper right' ) plt.title ( 'Expected spectrum after extrapolation' ) plt.grid () plt.tight_layout () plt.show () Here is an example of figure displayed with this command: Generate a vector of frequencies for the forward and backward extrapolations: freq_vect_forward = np.linspace ( freq_vect [ -1 ] +df,freq_vect [ -1 ] + ( df*Nextra ) ,Nextra ) freq_vect_backward = np.linspace ( freq_vect [ 0 ] - ( df* ( Nextra-2 )) ,freq_vect [ 0 ] -df,Nextra ) Display the original radar spectrum and the extrapolation using method 1: plt.figure ( figsize =( 11 ,5 )) plt.plot ( freq_vect*1e-9,np.real ( spec_vect ) , 'r-' ) plt.plot ( freq_vect*1e-9,abs ( spec_vect ) , 'k-' ) plt.plot ( freq_vect_backward*1e-9,np.real ( spec_vect_extra_1_b ) , 'y-' ) plt.plot ( freq_vect_backward*1e-9,abs ( spec_vect_extra_1_b ) , 'g-' ) plt.plot ( freq_vect_forward*1e-9,np.real ( spec_vect_extra_1_f ) , 'c-' ) plt.plot ( freq_vect_forward*1e-9,abs ( spec_vect_extra_1_f ) , 'b-' ) plt.axvspan (( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ 0 ] -df ) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.axvspan (( freq_vect [ -1 ] +df ) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9 ]) plt.ylim ([ -2.7,2.5 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Original radar spectrum (real part)' , 'Original radar spectrum (modulus)' , 'Backward extrapolation (real part)' , 'Backward extrapolation (modulus)' , 'Forward extrapolation (real part)' , 'Forward extrapolation (modulus)' ] ,loc = 'lower center' ,ncol = 3 ) plt.title ( 'Spectrum state-space extrapolation - method 1 (using the observability matrix)' ) plt.grid () plt.tight_layout () plt.show () Display the original radar spectrum and the extrapolation using method 2: plt.figure ( figsize =( 11 ,5 )) plt.plot ( freq_vect*1e-9,np.real ( spec_vect ) , 'r-' ) plt.plot ( freq_vect*1e-9,abs ( spec_vect ) , 'k-' ) plt.plot ( freq_vect_backward*1e-9,np.real ( spec_vect_extra_2_b ) , 'y-' ) plt.plot ( freq_vect_backward*1e-9,abs ( spec_vect_extra_2_b ) , 'g-' ) plt.plot ( freq_vect_forward*1e-9,np.real ( spec_vect_extra_2_f ) , 'c-' ) plt.plot ( freq_vect_forward*1e-9,abs ( spec_vect_extra_2_f ) , 'b-' ) plt.axvspan (( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ 0 ] -df ) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.axvspan (( freq_vect [ -1 ] +df ) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9 ]) plt.ylim ([ -2.7,2.5 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Original radar spectrum (real part)' , 'Original radar spectrum (modulus)' , 'Backward extrapolation (real part)' , 'Backward extrapolation (modulus)' , 'Forward extrapolation (real part)' , 'Forward extrapolation (modulus)' ] ,loc = 'lower center' ,ncol = 3 ) plt.title ( 'Spectrum state-space extrapolation - method 2 (using the controllability matrix)' ) plt.grid () plt.tight_layout () plt.show () Here is an example of figure displayed with this command for method 1: References Akaike (1974) Wax & Kailath (1985) Brindise & Vlachos (2017) Cuomo (1992) Piou (1999): Ciarletti et al. (2017) Raguso et al. (2018) Herv\u00e9 et al. (2020) Oudart et al. (2021) Gambacorta et al. (2022)","title":"PySSBWE"},{"location":"PySSBWE/#pyssbwe-package","text":"","title":"PySSBWE package"},{"location":"PySSBWE/#description","text":"The PySSBWE package is an \"advanced\" package of this library. It allows you to apply the State-Space Bandwidth Extrapolation (SSBWE) technique as defined by Piou (1999) to any to any radar spectrum. The SSBWE is a super-resolution technique, as it yields a better range resolution in time-domain than classic spectral estimation techniques (FFT). It is a state-space modelling version of the classic Bandwidth Extrapolation (BWE), this improved model making the technique more robust to noise and sub-surface attenuations. The SSBWE works this way: The input is the frequency-domain spectrum of the radar's reponse signal from a series of targets, with sub-surface attenuations. In this situation, the signal should in theory be a sum of complex sine-waves, with distortions following decreasing exponentials. A state-space model is fitted to this spectrum, using a state-space identification technique. The order of the model is estimated by Akaike's Information Criterion (AIC). One model is used to extrapolate the spectrum forward, and another to extrapolate the spectrum backward. The extrapolating factor is a user-defined parameter. The super-resolved time-domain sounding is obtained by IFFT. Zero-padding can be used for time-domain interpolation (this process is purely aesthetic). The spectrum's extrapolation factor is equal to the resolution enhancement factor after IFFT. The PySSBWE package contains the PySSBWE.SSBWE function, allowing you to apply the SSBWE directly to a given radar spectrum and get a super-resolved sounding. This function calls several other functions from the package, that you can call independently if needed: PySSBWE.statespace_model: fits a state-space model to a spectrum, using 2 state-space identification methods. PySSBWE.AIC: estimates the ideal order for a spectrum's state-space model using Akaike's Information Criterion. PySSBWE.MDL: estimates the ideal order for a spectrum's state-space model using the Minimum Description Length criterion. PySSBWE.two_line_fit: estimates the ideal order for a spectrum's state-space model using the \"two-line fit\" method. PySSBWE.statespace_extrapolation: extrapolates forward, backward or both a spectrum, given an AR model. In addition, this package also contains a function that can be used to retrieve information on the different targets' echoes from a spectrum's state-space model: PySSBWE.statespace_properties: retrieve the amplitudes, time-delays, and frequency-decays estimations of each echoes from a spectrum's state-space model.","title":"Description"},{"location":"PySSBWE/#importation","text":"Once the library is installed, the PySSBWE package can simply be imported: import PySSBWE","title":"Importation"},{"location":"PySSBWE/#recommendations","text":"","title":"Recommendations"},{"location":"PySSBWE/#the-order-of-the-ar-model","text":"The idea behind the state-space identification of the SSBWE technique is to seperate the singular values of signal from the singular values of noise in the input spectrum's Hankel matrix. The ideal order of a state-space model corresponds to the number of selected singular values being part of the signal sub-space. It is directly the number of complex sine-waves composing the spectrum, also equal to the number of targets sounded by the radar. If you have an a priori knowledge of the number of targets, you directly set the order of the model. If not, you can estimate it with Akaike's Information Criterion (AIC, see Akaike (1974)), implemented in PySSBWE, as recommended by Piou (1999). Other criteria are also available. The stability of the model not being guaranteed in the case of the SSBWE, a wrong estimation of the ideal model order can lead to diverging extrapolations, and thus to very high errors in time-domain.","title":"The order of the AR model"},{"location":"PySSBWE/#the-extrapolation-factor","text":"In theory, a sum of sine-wave can be extrapolated infinitely. However, in practical cases, errors accumulate with the extrapolation. For the BWE, Cuomo (1992) recommends an extrapolation factor of maximum 3. This is also the extrapolation factor used by Piou for the SSBWE (1999).","title":"The extrapolation factor"},{"location":"PySSBWE/#the-effect-of-side-lobes","text":"In the case of a radar signal spectrum obtained by FFT, 2 effects must be mitigated before SSBWE: If a window was applied to the signal, it must be inverted. The application of the FFT generates side-lobes effects on the borders of the spectrum. For this reason, Cuomo (1992) recommends to remove 5% of frequencies on each side of a spectrum before SSBWE. The same goes for SSBWE. In the case of a radar measuring only the real-part of a frequency spectrum, the imaginary part can be reconstructed by Hilbert transform. The FFT being part of Hilbert transform implementations, errors can also be expected on the border of the spectrum. We thus also recommend to cut 5% of samples on each side of a spectrum in this case. The PySSBWE.SSBWE function allows you to remove 5% of samples on each side of a spectrum before SSBWE.","title":"The effect of side-lobes"},{"location":"PySSBWE/#the-effect-of-distortions","text":"The SSBWE technique is based on the assumption that the spectrum of a radar response signal from targets is a sum of complex sine-waves, with only decreasing exponential distortions. In many practical applications, a radar response signal can differ from this model, due to various distortion effects. Such distortions can make the application of the direct application of the BWE impossible. We thus recommend to correct distortions prior to a SSBWE application. Different solutions are possible for different sources of distortion: Effect of the antennas gain: No antenna can transmit all frequencies with the same gain. This will cause distortions of sine-waves in a radar spectrum. You can try to compensate for this effect with a calibration radar measurement on a \"perfect reflector\" (a metallic sphere or a large metallic plate). From the spectrum of the echo from such target, the antennas gain can be determined, and inverted in all other radar measurements. This process is sometimes called \"whitening\" and is described in Oudart et al. (2021). As different temperatures can lead to significantly different amplitudes over a radar's bandwidth, for a successful whitening process we recommend to apply first a temperature correction (as the one described in Herv\u00e9 et al. (2020)). Effect of the ionosphere: The ionosphere of any planet has a frequency-dependent attenuation effect on electromagnetic waves. This will cause distortions of sine-waves in a radar spectrum. This effect can be compensated using a ionospheric model. For instance Gambacorta et al. (2022) used a ionospheric Gamma model before applying the SSBWE to MARSIS (Mars Express) soundings. Effect of subsurface attenuations: When a radar signal is transmitted through a sub-surface, it is affected by different frequency-dependent attenuations (absorption, scattering...). It can thus be expected that deeper echoes in a high-loss subsurface will not be correctly reconstructed by the classic BWE. The SSBWE accounts for this distortion effect, and the estimation of the level of attenuations at each target (the sum of absorption, scattering...) can even be extracted from the model.","title":"The effect of distortions"},{"location":"PySSBWE/#the-effect-of-noise","text":"The presence of noise in a signal impact the quality of the AR model determined by the Burg algorithm. For this reason, a high level of noise will impact the classic BWE results (echoes amplitudes and time-delays), as demonstrated in Oudart et al. (2021). The state-space model used by the SSBWE has a more robust noise model, and if the order of the model is chosen well, noise will impact much less the SSBWE than the BWE.","title":"The effect of noise"},{"location":"PySSBWE/#electromagnetic-interferences","text":"EM interferences can cause peaks in the measured radar spectrum. Such peaks will impair the AR modelling of the signal. The effect can be mitigated by detecting outliers in the spectrum, and then replacing them by interpolation, as proposed by Raguso et al. (2018).","title":"Electromagnetic interferences"},{"location":"PySSBWE/#cross-talk","text":"If the emission and reception antennas / channels are not the same, a cross-talk phenomenon can generate unwanted signals in the radar response. It is recommended to remove such effects prior to the application of the SSBWE. This can for instance be done by subtracting a \"free-space\" (without any targets) calibration signal to any radar response.","title":"Cross-talk"},{"location":"PySSBWE/#functions","text":"","title":"Functions"},{"location":"PySSBWE/#pyssbweaicsvn","text":"The PySSBWE.AIC function estimates the ideal state-space model order from the spectrum's Hankel matrix singular values, using AIC. See Akaike (1974) and Wax & Kailath (1985). This order corresponds to the number of singular values selected as being part of the signal's subspace, and is ideally equal to the number of target echoes in the radar signal. Inputs: sv: float 1D array of the spectrum's Hankel matrix singular values, in decreasing order. N: integer number of samples in the spectrum. Outputs: output_order: integer ideal state-space model order according to AIC.","title":"PySSBWE.AIC(sv,N)"},{"location":"PySSBWE/#pyssbwemdlsvn","text":"The PySSBWE.MDL function estimates the ideal state-space model order from the spectrum's Hankel matrix singular values, using MDL. See Wax & Kailath (1985). This order corresponds to the number of singular values selected as being part of the signal's subspace, and is ideally equal to the number of target echoes in the radar signal. Inputs: sv: float 1D array of the spectrum's Hankel matrix singular values, in decreasing order. N: integer number of samples in the spectrum. Outputs: output_order: integer ideal state-space model order according to MDL.","title":"PySSBWE.MDL(sv,N)"},{"location":"PySSBWE/#pyssbwessbwespecdfextra_factorzp_factorside_cuttrueorder0criterionaic","text":"The PySSBWE.SSBWE function applies the State-Space Bandwidth Extrapolation (SSBWE) to a radar signal's spectrum. The State-Space model is estimated using two methods: Method 1: estimation of the state-space model from the observability matrix. Method 2: estimation of the state-space model from the controllability matrix. Both models' results are returned by the function. Inputs: spec: complex 1D array containing the spectrum to which the SSBWE will be applied. df: float frequency step corresponding to spec [Hz]. extra_factor: float factor between the extrapolated and the original spectrum's bandwidths. zp_factor: float factor between the zero-padded and original spectrum's bandwidth. side_cut: (optional) boolean , 5% of samples are cut on each side of the spectrum if True. order: (optional) integer order of the state-space model (number of selected singular value, ideally equal to the number of radar targets), if = 0 the order is estimated by the selected criterion (AIC by default). criterion: (optional) string name of the method / criterion to use for the order estimation if order = 0 ('aic' = Akaike's Information Criterion / 'mdl' = Minimum Description Length / 'two_line_fit' = two-line fit approach). Outputs: output_ssbwe_1: complex 1D array extrapolated spectrum using SSBWE method 1. output_ssbwe_2: complex 1D array extrapolated spectrum using SSBWE method 2. time_ssbwe_vect: complex 1D array time axis corresponding to output_ssbwe_1 and output_ssbwe_2 [s]. Notes: Unlike the classic BWE (or the PBWE), where the Burg algorithm guaranties the stability of the model, the stability of the state-space model is not guaranteed. The order of the model is by default estimated using AIC. It can also be set by the user, or estimated with another method.","title":"PySSBWE.SSBWE(spec,df,extra_factor,zp_factor,side_cut=True,order=0,criterion='aic')"},{"location":"PySSBWE/#pyssbwestatespace_extrapolationyabcnextra","text":"The PySSBWE.statespace_extrapolation function extrapolates forward a spectrum given its state-space model. Inputs: y: complex 1D array containing the spectrum to be extrapolated. A: complex 2D array containing the state-space model's \"state matrix\". B: complex 1D array containing the state-space model's \"input matrix\". C: complex 1D array containing the state-space model's \"output matrix\". Nextra: integer number of samples to extrapolate from y. Outputs: y_extra: complex 1D array containing the forward extrapolation of y. Notes: This function only extrapolates a spectrum forward. To extrapolate a spectrum backward, you must flip the spectrum, fit a state-space model to it, extrapolate it forward, and eventually flip it again.","title":"PySSBWE.statespace_extrapolation(y,A,B,C,Nextra)"},{"location":"PySSBWE/#pyssbwestatespace_modelyorder0criterionaic","text":"The PySSBWE.statespace_model function fits a state-space model to a spectrum. The State-Space model is estimated using two methods: Method 1: estimation of the state-space model from the observability matrix. Method 2: estimation of the state-space model from the controllability matrix. Both models are returned by the function. Inputs: y: complex 1D array containing the spectrum to be modelled. order: (optional) integer order of the state-space model (number of selected singular value, ideally equal to the number of radar targets), if = 0 the order is estimated by the selected criterion (AIC by default). criterion: (optional) string name of the method / criterion to use for the order estimation if order = 0 ('aic' = Akaike's Information Criterion / 'mdl' = Minimum Description Length / 'two_line_fit' = two-line fit approach). Outputs: A1: complex 2D array containing the state-space model's \"state matrix\" obtained with method 1. B1: complex 2D array containing the state-space model's \"input matrix\" obtained with method 1. C1: complex 2D array containing the state-space model's \"output matrix\" obtained with method 1. A2: complex 2D array containing the state-space model's \"state matrix\" obtained with method 2. B2: complex 2D array containing the state-space model's \"input matrix\" obtained with method 2. C2: complex 2D array containing the state-space model's \"output matrix\" obtained with method 2. Notes: Unlike the Burg algorithm which guaranties the stability of the model, the stability of the state-space model is not guaranteed. The order of the model is by default estimated using AIC. It can also be set by the user, or estimated with another method.","title":"PySSBWE.statespace_model(y,order=0,criterion='aic')"},{"location":"PySSBWE/#pyssbwestatespace_propertiesabcdff1","text":"The PySSBWE.statespace_properties function retrieves the different echoes properties (complex amplitudes, time-delays, frequency-decays) from a spectrum's state-space model. Inputs: A: complex 2D array containing the spectrum state-space model's \"state matrix\". B: complex 1D array containing the spectrum state-space model's \"input matrix\". C: complex 1D array containing the spectrum state-space model's \"output matrix\". df: float frequency step of the modelled spectrum [Hz]. f1: float 1 st frequency of the modelled spectrum [Hz]. Outputs: amp: complex 1D array containing the estimated echoes complex amplitudes in the signal. td: float 1D array containing the estimated echoes time-delays [s]. dec: float_1D_array containing the estimated echoes frequency-decay [1/Hz].","title":"PySSBWE.statespace_properties(A,B,C,df,f1)"},{"location":"PySSBWE/#pyssbwetwo_line_fitsv","text":"The PySSBWE.two_line_fit function estimates the ideal state-space model order from the spectrum's Hankel matrix singular values, using a \"two-line fit\" approach. See Brindise & Vlachos (2017). This order corresponds to the number of singular values selected as being part of the signal's subspace, and is ideally equal to the number of target echoes in the radar signal. Inputs: sv: float 1D array of the spectrum's Hankel matrix singular values, in decreasing order. Outputs: output_order: integer ideal state-space model order according to the \"two-line fit\" approach.","title":"PySSBWE.two_line_fit(sv)"},{"location":"PySSBWE/#example","text":"2 example scripts are proposed with the same synthetic radar scenario for the PySSBWE package: An application of PySSBWE.SSBWE and PySSBWE.statespace_properties on a synthetic radar signal is proposed in examples/script_example_PySSBWE_SSBWE.py . A manual use of PySSBWE.statespace_model and PySSBWE.statespace_extrapolation on a synthetic radar signal is proposed in examples/script_example_PySSBWE_extrapolation.py . In the following, these 2 scripts are explained as a single tutorial:","title":"Example"},{"location":"PySSBWE/#presentation-of-the-scenario","text":"The synthetic radar signal example (inspired by the WISDOM GPR of the ExoMars rover mission, Ciarletti et al. (2017)): A SFCW (Stepped Frequency Continuous Wave) radar working between 0.5 and 3 GHz measures a 1001 frequencies spectrum when sounding. Only the In-phase component (real part of the spectrum) is measured, the Quadrature component (imaginary part of the spectrum) is reconstructed by Hilbert transform. Two targets in free-space are seperated by 5 cm, slightly below the radar's free-space resolution. With these targets' echoes (or complex sine waves in frequency domain) are associated different complex amplitudes and different decays in frequency-domain. The measured spectrum is corrupted by a white-noise of standard deviation 10X smaller than the complex sine-waves' amplitudes. The State-Space Bandwidth Extrapolation (SSBWE) is applied to this radar's signal using the PyBWE function_SSBWE: Most of the estimation errors when reconstructing a complex spectrum with the Hilbert transform are on the far sides of the spectrum. For this reason, we cut 5% of frequencies on each side of the spectrum before SSBWE. We would do the same for a radar working in time-domain, as most errors in FFT estimation are also on each side of the spectrum. This process is useless for a radar working in the frequency-domain and measuring both In-Phase and Quadrature components of the spectrum. We then fit a state-space model to the spectrum, first in the forward and then the backward directions. We use these 2 models to extrapolate the spectrum on each side, to obtain a bandwidth 3X larger (maximum extrapolation factor recommended by Cuomo (1992)). A bandwidth X3 yields a resolution X3 better in time-domain. The extrapolated spectrum is eventually converted to a time-domain signal by IFFT, with zero-padding to interpolate the signal X10. This interpolation is purely aesthetic. From the state-space model of the spectrum, the properties of each echo (amplitude, time-delay, frequency-domain decay) can be estimated. This is done in the last part of this example. In the following example the order of the model (= number of echoes) is estimated using AIC. Other criteria can be selected. The order can also be forced by the user in the PySSBWE functions statespace_model and SSBWE with an optional parameter \"order\" if the number of echoes is known. 2 methods can be used to fit a state-space model to a spectrum: *Method 1: using the observability matrix. *Method 2: using the controllability matrix. This scenario requires the following libraries: import matplotlib.pyplot as plt import numpy as np from math import pi from scipy.signal import hilbert import PySSBWE","title":"Presentation of the scenario"},{"location":"PySSBWE/#the-synthetic-signal-generation","text":"In this section we describe how to generate analytically a synthetic radar sounding to test the PySSBWE package. Generate a vector of 1001 frequencies between 0.5 and 3 GHz: freq_vect = np.linspace ( 0 .5e9,3e9,1001 ) Distance (m) between two radar targets in free-space (returning two echoes) and the radar: dist_target1 = 1 dist_target2 = 1 .07 Amplitude associated with each target echo: ampli_target1 = 1 ampli_target2 = 0 .75 Frequency decay associated with each target echo (1/Hz): decay_target1 = 0 .25e-9 decay_target2 = 0 .5e-9 Generate a sum of two complex sine-waves corresponding to the targets' echoes (each with an amplitude of 1): spec_vect = ( ampli_target1*np.exp (( -decay_target1+ ( 1j*4*pi*dist_target1/3e8 )) *freq_vect )) + ( ampli_target2*np.exp (( -decay_target2+ ( 1j*4*pi*dist_target2/3e8 )) *freq_vect )) Only keep the real part of the spectrum (In-phase component): spec_vect = np.real ( spec_vect ) Add a white noise (standard deviation 0.1) to this spectrum signal: wn_vect = np.random.normal ( 0 ,0.1,spec_vect.shape ) spec_vect += wn_vect Reconstruct a complex signal with the Hilbert transform: spec_vect = hilbert ( spec_vect )[ ::2 ] freq_vect = freq_vect [ ::2 ] This is the signal to which we will apply the SSBWE.","title":"The synthetic signal generation"},{"location":"PySSBWE/#the-application-of-the-ssbwe","text":"The SSBWE can be applied directly to the spectrum using the PySSBWE.SSBWE function. Extrapolation factor (=< 3 recommended by Cuomo (1992)): extra_factor = 3 Zero-padding factor (= time domain interpolation factor): zp_factor = 10 Cut 5% of samples on each side of the spectrum: side_cut = True Calculate the spectrum's frequency step: df = freq_vect [ 1 ] -freq_vect [ 0 ] Application of the BWE to the spectrum: output_ssbwe_1, output_ssbwe_2, time_ssbwe_vect = PySSBWE.SSBWE ( spec_vect,df,extra_factor,zp_factor,side_cut ) output_ssbwe_1 and output_ssbwe_2 contains the time-domain radar soundings after SSBWE (method 1 and 2), ready to be displayed with time axis time_ssbwe_vect.","title":"The application of the SSBWE:"},{"location":"PySSBWE/#display-of-the-ssbwe-results","text":"In this section we display the SSBWE results compared to the original radar sounding, for methods 1 and 2. Generate a time vector corresponding to the time-domain transform: time_vect = np.linspace ( 0 ,1/df,zp_factor*len ( spec_vect )) Display the original radar sounding and the SSBWE version using method 1: plt.figure ( figsize =( 10 ,5 )) plt.plot ( time_vect*1e9,abs ( 1 .85*np.fft.fft ( spec_vect*np.hamming ( len ( spec_vect )) ,zp_factor*len ( spec_vect ))) /len ( spec_vect ) , 'k-' ) plt.plot ( time_ssbwe_vect*1e9,abs ( output_ssbwe_1 ) , 'r-' ) plt.xlim ([ 5 ,9 ]) plt.ylim ([ -0.05,0.7 ]) plt.xlabel ( 'Time delays (ns)' ) plt.ylabel ( 'Normalized amplitude' ) plt.legend ([ 'Original radar sounding' , 'Radar sounding after SSBWE' ] ,loc = 'upper right' ) plt.title ( 'SSBWE application - method 1 (using the observability matrix)' ) plt.grid () plt.tight_layout () plt.show () Display the original radar sounding and the SSBWE version using method 2: plt.figure ( figsize =( 10 ,5 )) plt.plot ( time_vect*1e9,abs ( 1 .85*np.fft.fft ( spec_vect*np.hamming ( len ( spec_vect )) ,zp_factor*len ( spec_vect ))) /len ( spec_vect ) , 'k-' ) plt.plot ( time_ssbwe_vect*1e9,abs ( output_ssbwe_2 ) , 'r-' ) plt.xlim ([ 5 ,9 ]) plt.ylim ([ -0.05,0.7 ]) plt.xlabel ( 'Time delays (ns)' ) plt.ylabel ( 'Normalized amplitude' ) plt.legend ([ 'Original radar sounding' , 'Radar sounding after SSBWE' ] ,loc = 'upper right' ) plt.title ( 'SSBWE application - method 2 (using the controllability matrix)' ) plt.grid () plt.tight_layout () plt.show () (The X 1.85 factor in amplitude corresponds to the compensation for the Hamming window). Here is an example of figure displayed with this command for method 1:","title":"Display of the SSBWE results:"},{"location":"PySSBWE/#extraction-of-the-echoes-properties","text":"In this section we show how to extract the echoes properties (amplitudes, time-delays, frequency-domain decays) from a spectrum's state-space model. Manually cut 5% of frequencies of each side of the spectrum: spec_vect_cut = spec_vect [ round ( len ( spec_vect ) *0.05 ) :len ( spec_vect ) -round ( len ( spec_vect ) *0.05 )] freq_vect_cut = freq_vect [ round ( len ( freq_vect ) *0.05 ) :len ( freq_vect ) -round ( len ( freq_vect ) *0.05 )] Fit a state-space model to the spectrum: [ A1,B1,C1,A2,B2,C2 ] = PySSBWE.statespace_model ( spec_vect_cut ) Retrieve the spectrum's frequency step and 1 st frequency: df = freq_vect_cut [ 1 ] -freq_vect_cut [ 0 ] f1 = freq_vect_cut [ 0 ] Extract the echoes properties from the state-space model obtained with method 1: [ amp_1,td_1,dec_1 ] = PySSBWE.statespace_properties ( A1,B1,C1,df,f1 ) Extract the echoes properties from the state-space model obtained with method 2: [ amp_2,td_2,dec_2 ] = PySSBWE.statespace_properties ( A2,B2,C2,df,f1 ) Print the echoes amplitudes (module), range (m) and frequency decays (1/GHz) obtained using method 1: print ( \"---Echoes properties estimation (method 1: using observability matrix)---\" ) print ( \"Module amplitude of echoes: \" +str ( abs ( amp_1 ))) print ( \"Distance of targets from the radar (m): \" +str ( 0 .5*td_1*3e8 )) print ( \"Frequency-domain decay of echoes (1/GHz): \" +str ( dec_1*1e9 )) print ( \"-------------------------------------------------------------------------\" ) Print the echoes amplitudes (module), range (m) and frequency decays (1/GHz) obtained using method 2: print ( \"---Echoes properties estimation (method 2: using controllability matrix)---\" ) print ( \"Module amplitude of echoes: \" +str ( abs ( amp_2 ))) print ( \"Distance of targets from the radar (m): \" +str ( 0 .5*td_2*3e8 )) print ( \"Frequency-domain decay of echoes (1/GHz): \" +str ( dec_2*1e9 )) print ( \"---------------------------------------------------------------------------\" )","title":"Extraction of the echoes properties:"},{"location":"PySSBWE/#manual-extrapolation","text":"If you want to model and extrapolate the spectrum manually, it can also be done using the PySSBWE.statespace_model and PySSBWE.statespace_extrapolation functions. Cutting 5% of frequencies on each side of the spectrum: spec_vect = spec_vect [ round ( len ( spec_vect ) *0.05 ) :len ( spec_vect ) -round ( len ( spec_vect ) *0.05 )] freq_vect = freq_vect [ round ( len ( freq_vect ) *0.05 ) :len ( freq_vect ) -round ( len ( freq_vect ) *0.05 )] Flip for a backward version of the spectrum: spec_vect_b = np.flip ( spec_vect ) Retrieve the numbers of samples in the spectrum: N = len ( spec_vect ) Number of samples to be extrapolated on each side of the spectrum to get an extrapolation factor of 3: Nextra = round ((( 3 *N ) -N ) //2 ) +1 Fit a state-space model to the spectrum for forward extrapolation: [ A1_f,B1_f,C1_f,A2_f,B2_f,C2_f ] = PySSBWE.statespace_model ( spec_vect ) Fit a state-space model to the flipped spectrum for backward extrapolation: [ A1_b,B1_b,C1_b,A2_b,B2_b,C2_b ] = PySSBWE.statespace_model ( spec_vect_b ) Forward extrapolation of the spectrum (obtained with method 1 and 2): spec_vect_extra_1_f = PySSBWE.statespace_extrapolation ( spec_vect,A1_f,B1_f,C1_f,Nextra ) spec_vect_extra_2_f = PySSBWE.statespace_extrapolation ( spec_vect,A2_f,B2_f,C2_f,Nextra ) Backward extrapolation of the spectrum (obtained with method 1 and 2): spec_vect_extra_1_b = PySSBWE.statespace_extrapolation ( spec_vect_b,A1_b,B1_b,C1_b,Nextra ) spec_vect_extra_2_b = PySSBWE.statespace_extrapolation ( spec_vect_b,A2_b,B2_b,C2_b,Nextra ) Flip the backward extrapolation (obtained with method 1 and 2): spec_vect_extra_1_b = np.flip ( spec_vect_extra_1_b ) spec_vect_extra_2_b = np.flip ( spec_vect_extra_2_b ) spec_vect_extra_1_f and spec_vect_extra_1_b are the forward and backward spectrum extrapolations using method 1. spec_vect_extra_2_f and spec_vect_extra_2_b are the forward and backward spectrum extrapolations using method 2.","title":"Manual extrapolation:"},{"location":"PySSBWE/#display-of-the-extrapolation-result","text":"In this section, we display the state-space extrapolated spectra (methods 1 and 2), along with the expected spectra (noise-free) after extrapolation for comparison. Generate the expected spectrum after extrapolation for comparison: df = freq_vect [ 1 ] -freq_vect [ 0 ] freq_vect_expected = np.linspace ( freq_vect [ 0 ] - ( df* ( Nextra-2 )) ,freq_vect [ -1 ] + ( df*Nextra ) ,N+ ( Nextra*2 )) spec_vect_expected = ( ampli_target1*np.exp (( -decay_target1+ ( 1j*4*pi*dist_target1/3e8 )) *freq_vect_expected )) + ( ampli_target2*np.exp (( -decay_target2+ ( 1j*4*pi*dist_target2/3e8 )) *freq_vect_expected )) Display the expected spectrum after extrapolation: plt.figure ( figsize =( 10 ,5 )) plt.plot ( freq_vect_expected*1e-9,np.real ( spec_vect_expected ) , 'r-' ) plt.plot ( freq_vect_expected*1e-9,abs ( spec_vect_expected ) , 'k-' ) plt.axvspan (( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ 0 ] -df ) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.axvspan (( freq_vect [ -1 ] +df ) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9 ]) plt.ylim ([ -2.5,2.5 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Real part' , 'Modulus' ] , loc = 'upper right' ) plt.title ( 'Expected spectrum after extrapolation' ) plt.grid () plt.tight_layout () plt.show () Here is an example of figure displayed with this command: Generate a vector of frequencies for the forward and backward extrapolations: freq_vect_forward = np.linspace ( freq_vect [ -1 ] +df,freq_vect [ -1 ] + ( df*Nextra ) ,Nextra ) freq_vect_backward = np.linspace ( freq_vect [ 0 ] - ( df* ( Nextra-2 )) ,freq_vect [ 0 ] -df,Nextra ) Display the original radar spectrum and the extrapolation using method 1: plt.figure ( figsize =( 11 ,5 )) plt.plot ( freq_vect*1e-9,np.real ( spec_vect ) , 'r-' ) plt.plot ( freq_vect*1e-9,abs ( spec_vect ) , 'k-' ) plt.plot ( freq_vect_backward*1e-9,np.real ( spec_vect_extra_1_b ) , 'y-' ) plt.plot ( freq_vect_backward*1e-9,abs ( spec_vect_extra_1_b ) , 'g-' ) plt.plot ( freq_vect_forward*1e-9,np.real ( spec_vect_extra_1_f ) , 'c-' ) plt.plot ( freq_vect_forward*1e-9,abs ( spec_vect_extra_1_f ) , 'b-' ) plt.axvspan (( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ 0 ] -df ) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.axvspan (( freq_vect [ -1 ] +df ) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9 ]) plt.ylim ([ -2.7,2.5 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Original radar spectrum (real part)' , 'Original radar spectrum (modulus)' , 'Backward extrapolation (real part)' , 'Backward extrapolation (modulus)' , 'Forward extrapolation (real part)' , 'Forward extrapolation (modulus)' ] ,loc = 'lower center' ,ncol = 3 ) plt.title ( 'Spectrum state-space extrapolation - method 1 (using the observability matrix)' ) plt.grid () plt.tight_layout () plt.show () Display the original radar spectrum and the extrapolation using method 2: plt.figure ( figsize =( 11 ,5 )) plt.plot ( freq_vect*1e-9,np.real ( spec_vect ) , 'r-' ) plt.plot ( freq_vect*1e-9,abs ( spec_vect ) , 'k-' ) plt.plot ( freq_vect_backward*1e-9,np.real ( spec_vect_extra_2_b ) , 'y-' ) plt.plot ( freq_vect_backward*1e-9,abs ( spec_vect_extra_2_b ) , 'g-' ) plt.plot ( freq_vect_forward*1e-9,np.real ( spec_vect_extra_2_f ) , 'c-' ) plt.plot ( freq_vect_forward*1e-9,abs ( spec_vect_extra_2_f ) , 'b-' ) plt.axvspan (( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ 0 ] -df ) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.axvspan (( freq_vect [ -1 ] +df ) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9, facecolor = 'k' , alpha = 0 .1 ) plt.xlim ([( freq_vect [ 0 ] - ( df* ( Nextra-2 ))) *1e-9, ( freq_vect [ -1 ] + ( df*Nextra )) *1e-9 ]) plt.ylim ([ -2.7,2.5 ]) plt.xlabel ( 'Frequency (GHz)' ) plt.ylabel ( 'Amplitude' ) plt.legend ([ 'Original radar spectrum (real part)' , 'Original radar spectrum (modulus)' , 'Backward extrapolation (real part)' , 'Backward extrapolation (modulus)' , 'Forward extrapolation (real part)' , 'Forward extrapolation (modulus)' ] ,loc = 'lower center' ,ncol = 3 ) plt.title ( 'Spectrum state-space extrapolation - method 2 (using the controllability matrix)' ) plt.grid () plt.tight_layout () plt.show () Here is an example of figure displayed with this command for method 1:","title":"Display of the extrapolation result:"},{"location":"PySSBWE/#references","text":"Akaike (1974) Wax & Kailath (1985) Brindise & Vlachos (2017) Cuomo (1992) Piou (1999): Ciarletti et al. (2017) Raguso et al. (2018) Herv\u00e9 et al. (2020) Oudart et al. (2021) Gambacorta et al. (2022)","title":"References"},{"location":"community/","text":"Community guidelines Contribute We are open to contributions to improve PyBWE. Please fork the repository to make your updates. For each new update, please follow these guidelines: For any new functions, add unit, integration and if possible performance tests to the corresponding test scripts in test . If possible, new example scripts should also be added to examples . For any change to PyBWE, update the documentation accordingly in docs . Keep the code style (the naming of functions/scripts, the headers, sections...) and comment your updates. Report issues Feel free to report any issues through GitHub Issues . To help us fix the issues you want to report, please: Include in the title and/or in the text, names of the packages and functions for which the issue is observed. For reproducibility, add to the text your OS, your Python version, and your PyBWE version. Add to the text a description of the expected and the observed behaviours. Include any output, error message or screenshot relevant to understand the issue. Support If you need support using PyBWE, you can either: Look at the documentation: PyBWE website Contact us directly: nicolas.oudart@latmos.ipsl.fr","title":"Community guidelines"},{"location":"community/#community-guidelines","text":"","title":"Community guidelines"},{"location":"community/#contribute","text":"We are open to contributions to improve PyBWE. Please fork the repository to make your updates. For each new update, please follow these guidelines: For any new functions, add unit, integration and if possible performance tests to the corresponding test scripts in test . If possible, new example scripts should also be added to examples . For any change to PyBWE, update the documentation accordingly in docs . Keep the code style (the naming of functions/scripts, the headers, sections...) and comment your updates.","title":"Contribute"},{"location":"community/#report-issues","text":"Feel free to report any issues through GitHub Issues . To help us fix the issues you want to report, please: Include in the title and/or in the text, names of the packages and functions for which the issue is observed. For reproducibility, add to the text your OS, your Python version, and your PyBWE version. Add to the text a description of the expected and the observed behaviours. Include any output, error message or screenshot relevant to understand the issue.","title":"Report issues"},{"location":"community/#support","text":"If you need support using PyBWE, you can either: Look at the documentation: PyBWE website Contact us directly: nicolas.oudart@latmos.ipsl.fr","title":"Support"},{"location":"credits/","text":"Credits \u00a9 Nicolas OUDART Contributions from the WISDOM science team: Val\u00e9rie CIARLETTI, Alice LE GALL, Emile BRIGHI. Contributions from interns: Eloa EGUILUZ-BLANCO, Nathan GILLES-LORDET (2024). LATMOS/IPSL, UVSQ Universit\u00e9 Paris-Saclay, Guyancourt, France Citation OUDART Nicolas (2024), PyBWE: Python tools for Bandwidth Extrapolation of radar signals. DOI: 10.5281/zenodo.11253430 License This package is released under a MIT open source license.","title":"Credits"},{"location":"credits/#credits","text":"\u00a9 Nicolas OUDART Contributions from the WISDOM science team: Val\u00e9rie CIARLETTI, Alice LE GALL, Emile BRIGHI. Contributions from interns: Eloa EGUILUZ-BLANCO, Nathan GILLES-LORDET (2024). LATMOS/IPSL, UVSQ Universit\u00e9 Paris-Saclay, Guyancourt, France","title":"Credits"},{"location":"credits/#citation","text":"OUDART Nicolas (2024), PyBWE: Python tools for Bandwidth Extrapolation of radar signals. DOI: 10.5281/zenodo.11253430","title":"Citation"},{"location":"credits/#license","text":"This package is released under a MIT open source license.","title":"License"},{"location":"installation/","text":"Library installation and update Installation from PyPI Installation: pip install PyBWE Update: pip install PyBWE --upgrade Packages: This library contains 3 packages: PyBWE: Plain vanilla package . It contains the BWE functions, as well as the sub-functions allowing you to model and extrapolate a radar spectrum. PyPBWE: Advanced package . It contains the PBWE function, as well as the sub-functions allowing you to model and extrapolate a polarimetric radar spectra. PySSBWE: Advanced package . It contains the SSBWE function, as well as the sub-functions allowing you to model and extrapolate a radar spectrum, as well as extracting echoes information from it. PyBWE should be used by default. PyPBWE can be used only if the radar has more than one polarimetric channel. SSBWE can be used in high noise-level or in high attenuations situations, but the stability of the model is not guaranteed. See the documentation for more information on the functions contained in each package. Each package can be imported the following way: import PyBWE import PyPBWE import PySSBWE","title":"Installation"},{"location":"installation/#library-installation-and-update","text":"","title":"Library installation and update"},{"location":"installation/#installation-from-pypi","text":"Installation: pip install PyBWE Update: pip install PyBWE --upgrade","title":"Installation from PyPI"},{"location":"installation/#packages","text":"This library contains 3 packages: PyBWE: Plain vanilla package . It contains the BWE functions, as well as the sub-functions allowing you to model and extrapolate a radar spectrum. PyPBWE: Advanced package . It contains the PBWE function, as well as the sub-functions allowing you to model and extrapolate a polarimetric radar spectra. PySSBWE: Advanced package . It contains the SSBWE function, as well as the sub-functions allowing you to model and extrapolate a radar spectrum, as well as extracting echoes information from it. PyBWE should be used by default. PyPBWE can be used only if the radar has more than one polarimetric channel. SSBWE can be used in high noise-level or in high attenuations situations, but the stability of the model is not guaranteed. See the documentation for more information on the functions contained in each package. Each package can be imported the following way: import PyBWE import PyPBWE import PySSBWE","title":"Packages:"},{"location":"performance_tests/","text":"Performance tests This library proposes performance tests for the integrated methods PyBWE.BWE, PyPBWE.PBWE and PySSBWE.SSBWE, to ensure modifications will not cause performance regressions. These tests can be launched on request as GitHub actions ( test-script.yml , jobs perfoTestBWE , perfoTestPBWE and perfoTestSSBWE ). Reports are saved as artifacts. Performance facing white-noise This library proposes one white-noise performance test for each package's integrated method PyBWE.BWE, PyPBWE.PBWE and PySSBWE.SSBWE. These tests are defined in the following scripts: test/script_test_performances_white_noise_BWE.py test/script_test_performances_white_noise_PBWE.py test/script_test_performances_white_noise_SSBWE.py These tests follow a scenario similar to the example scripts of each package. The test scenario Synthetic radar signals are generated (inspired by the WISDOM GPR of the ExoMars rover mission, Ciarletti et al. (2017)): A SFCW (Stepped Frequency Continuous Wave) radar working between 0.5 and 3 GHz measures a 1001 frequencies spectrum when sounding. Only the In-phase component (real part of the spectrum) is measured, the Quadrature component (imaginary part of the spectrum) is reconstructed by Hilbert transform. Two targets in free-space are seperated by a given distance, slightly below the radar's free-space resolution. These targets generate echoes of given amplitudes in the radar's signal, or complex sine-waves in the measured spectrum. The measured spectrum is corrupted by a white-noise, with a standard deviation leading to a given SNR. Each script will apply the BWE, PBWE or SSBWE to synthetic radar signals generated for given distances between the targets, and given SNRs. For each SNR, a given number of white-noise cases will be tested, with the same random seed to ensure the test's reproducibility. The test parameters These test parameters can be modified by the user, but to follow the performances of the methods we recommend to keep them as defined in the script. The list of distances between targets (in m) to be tested is given by: list_dist_targets = [ 0 .04,0.06,0.08,0.1,0.12 ] The list of SNR values (in dB) to be tested is given by: list_snr_levels = [ 6 ,14,20,40,60 ] In a Monte-Carlo approach, the number of white-noise cases to be tested is given by: nb_noise_case = 1000 1000 white-noise cases are proposed for the BWE and SSBWE. The multi-channel version of the Burg algorithm used in the PBWE being significantly longer to run, we propose 25 noise cases instead. In addition to these test parameters, scenario parameters can also be modified if necessary. The scenario parameters The amplitude of the 2 echoes corresponding to the 2 targets can be set: amp_target1 = 1 amp_target2 = 1 In the case of the PBWE, the amplitudes can be set for each polarimetric channel 00 and 11: amp_target1_00 = 1 amp_target2_00 = 1 amp_target1_11 = 1 amp_target2_11 = -1 The distance between the 1 st target and the radar's antennas: dist_target1 = 1 The peak detection threshold on amplitude, for an echo to be \"detected\": detection_level = 0 .5 The chosen value corresponds to a -6 dB criterion compared to the expected echoes amplitudes. An additional parameter can be found for the SSBWE method, the order of the model: param_order = 2 We set this parameter to 2, as we know 2 targets are in front of the antennas. This is of course an ideal case, and Akaike's Information Criterion (AIC) can be used instead by setting this parameter to zero. For the BWE, PBWE and SSBWE functions, the default configuration will be tested. The test metrics To evaluate the performances of the BWE, PBWE and SSBWE methods, we selected several metrics, corresponding to the objectives of radar range resolution enhancement: Being able to detect the presence of the 2 echoes, to accurately measure the distance between them, and to accurately measure the amplitude of each echo. One metric is returned for each couple distance between targets / SNR. Here are the selected metrics: The percentage of times the 2 echoes are detected in the tested white-noise cases, according to the user defined threshold. The mean and std of the error on the distance between targets (m), estimated from the 2 echoes' time-delays measured in each white-noise cases. The mean and std of the relative error on the 1 st echo's amplitude (%), measured in each white-noise case. The mean and std of the relative error on the 2 nd echo's amplitude (%), measured in each white-noise case. The test report For each method (BWE, PBWE and SSBWE), a Markdown test report will be exported. Each section of this Markdown files will correspond to a specific test metric. After running the tests, the reports can be found in: test/PyBWE_Report_test_performances_white_noise.md test/PyPBWE_Report_test_performances_white_noise.md test/PySSBWE_Report_test_performances_white_noise.md In the case of the PBWE, as 2 co-polarimetric channels 00 and 11 are generated for the test, we return the metrics for each channel. In the case of the SSBWE, as 2 methods can be used to determine the signal model (method 1 with the observability matrix, method 2 with the controllability matrix), we return the metrics for each method. References The white-noise tests of the BWE proposed in this library are similar to the ones proposed in: Oudart et al. (2021) The white-noise tests of the BWE, PBWE and SSBWE proposed in this library are similar to the ones proposed in: Oudart, thesis (2021)","title":"Performance tests"},{"location":"performance_tests/#performance-tests","text":"This library proposes performance tests for the integrated methods PyBWE.BWE, PyPBWE.PBWE and PySSBWE.SSBWE, to ensure modifications will not cause performance regressions. These tests can be launched on request as GitHub actions ( test-script.yml , jobs perfoTestBWE , perfoTestPBWE and perfoTestSSBWE ). Reports are saved as artifacts.","title":"Performance tests"},{"location":"performance_tests/#performance-facing-white-noise","text":"This library proposes one white-noise performance test for each package's integrated method PyBWE.BWE, PyPBWE.PBWE and PySSBWE.SSBWE. These tests are defined in the following scripts: test/script_test_performances_white_noise_BWE.py test/script_test_performances_white_noise_PBWE.py test/script_test_performances_white_noise_SSBWE.py These tests follow a scenario similar to the example scripts of each package.","title":"Performance facing white-noise"},{"location":"performance_tests/#the-test-scenario","text":"Synthetic radar signals are generated (inspired by the WISDOM GPR of the ExoMars rover mission, Ciarletti et al. (2017)): A SFCW (Stepped Frequency Continuous Wave) radar working between 0.5 and 3 GHz measures a 1001 frequencies spectrum when sounding. Only the In-phase component (real part of the spectrum) is measured, the Quadrature component (imaginary part of the spectrum) is reconstructed by Hilbert transform. Two targets in free-space are seperated by a given distance, slightly below the radar's free-space resolution. These targets generate echoes of given amplitudes in the radar's signal, or complex sine-waves in the measured spectrum. The measured spectrum is corrupted by a white-noise, with a standard deviation leading to a given SNR. Each script will apply the BWE, PBWE or SSBWE to synthetic radar signals generated for given distances between the targets, and given SNRs. For each SNR, a given number of white-noise cases will be tested, with the same random seed to ensure the test's reproducibility.","title":"The test scenario"},{"location":"performance_tests/#the-test-parameters","text":"These test parameters can be modified by the user, but to follow the performances of the methods we recommend to keep them as defined in the script. The list of distances between targets (in m) to be tested is given by: list_dist_targets = [ 0 .04,0.06,0.08,0.1,0.12 ] The list of SNR values (in dB) to be tested is given by: list_snr_levels = [ 6 ,14,20,40,60 ] In a Monte-Carlo approach, the number of white-noise cases to be tested is given by: nb_noise_case = 1000 1000 white-noise cases are proposed for the BWE and SSBWE. The multi-channel version of the Burg algorithm used in the PBWE being significantly longer to run, we propose 25 noise cases instead. In addition to these test parameters, scenario parameters can also be modified if necessary.","title":"The test parameters"},{"location":"performance_tests/#the-scenario-parameters","text":"The amplitude of the 2 echoes corresponding to the 2 targets can be set: amp_target1 = 1 amp_target2 = 1 In the case of the PBWE, the amplitudes can be set for each polarimetric channel 00 and 11: amp_target1_00 = 1 amp_target2_00 = 1 amp_target1_11 = 1 amp_target2_11 = -1 The distance between the 1 st target and the radar's antennas: dist_target1 = 1 The peak detection threshold on amplitude, for an echo to be \"detected\": detection_level = 0 .5 The chosen value corresponds to a -6 dB criterion compared to the expected echoes amplitudes. An additional parameter can be found for the SSBWE method, the order of the model: param_order = 2 We set this parameter to 2, as we know 2 targets are in front of the antennas. This is of course an ideal case, and Akaike's Information Criterion (AIC) can be used instead by setting this parameter to zero. For the BWE, PBWE and SSBWE functions, the default configuration will be tested.","title":"The scenario parameters"},{"location":"performance_tests/#the-test-metrics","text":"To evaluate the performances of the BWE, PBWE and SSBWE methods, we selected several metrics, corresponding to the objectives of radar range resolution enhancement: Being able to detect the presence of the 2 echoes, to accurately measure the distance between them, and to accurately measure the amplitude of each echo. One metric is returned for each couple distance between targets / SNR. Here are the selected metrics: The percentage of times the 2 echoes are detected in the tested white-noise cases, according to the user defined threshold. The mean and std of the error on the distance between targets (m), estimated from the 2 echoes' time-delays measured in each white-noise cases. The mean and std of the relative error on the 1 st echo's amplitude (%), measured in each white-noise case. The mean and std of the relative error on the 2 nd echo's amplitude (%), measured in each white-noise case.","title":"The test metrics"},{"location":"performance_tests/#the-test-report","text":"For each method (BWE, PBWE and SSBWE), a Markdown test report will be exported. Each section of this Markdown files will correspond to a specific test metric. After running the tests, the reports can be found in: test/PyBWE_Report_test_performances_white_noise.md test/PyPBWE_Report_test_performances_white_noise.md test/PySSBWE_Report_test_performances_white_noise.md In the case of the PBWE, as 2 co-polarimetric channels 00 and 11 are generated for the test, we return the metrics for each channel. In the case of the SSBWE, as 2 methods can be used to determine the signal model (method 1 with the observability matrix, method 2 with the controllability matrix), we return the metrics for each method.","title":"The test report"},{"location":"performance_tests/#references","text":"The white-noise tests of the BWE proposed in this library are similar to the ones proposed in: Oudart et al. (2021) The white-noise tests of the BWE, PBWE and SSBWE proposed in this library are similar to the ones proposed in: Oudart, thesis (2021)","title":"References"},{"location":"references/","text":"References BWE: Bowling (1977) Cuomo (1992) Moore (1997) PBWE: Suwa and Iwamoto (2003) Suwa and Iwamoto (2007) SSBWE: Piou (1999): Planetary science applications: Mastrogiuseppe et al. (2014) Raguso et al. (2018) Oudart et al. (2021) Gambacorta et al. (2022) Eide et al. (2022)","title":"References"},{"location":"references/#references","text":"BWE: Bowling (1977) Cuomo (1992) Moore (1997) PBWE: Suwa and Iwamoto (2003) Suwa and Iwamoto (2007) SSBWE: Piou (1999): Planetary science applications: Mastrogiuseppe et al. (2014) Raguso et al. (2018) Oudart et al. (2021) Gambacorta et al. (2022) Eide et al. (2022)","title":"References"},{"location":"unit_integration_tests/","text":"Unit tests This library proposes unit tests for all unit functions of packages PyBWE, PyPBWE and PySSBWE, to ensure they run independently as expected. These tests can be launched as GitHub actions ( test-script.yml , jobs unitTestBWE , unitTestPBWE and unitTestSSBWE ). The output is printed in the console. The unit test scripts for the PyBWE, PyPBWE and PySSBWE packages in this library can be found at: test/script_unit_test_BWE.py test/script_unit_test_PBWE.py test/script_unit_test_SSBWE.py Test scenario The unit tests for packages PyBWE, PyPBWE and PySSBWE are performed on synthetic radar data. All 3 are based on a similar scenario: 2 targets in sight of the radar, at distances 1 and 1.1 m, generate echoes in the radar signal of amplitudes 1 and 1. The radar output is a spectrum of 151 frequencies between 1.5 and 3 GHz. The spectrum is corrupted by a white-noise of a low standard deviation 1e-6 (to ensure a certain reproducibility of results). In the case of PyPBWE, 2 signals are generated for 2 co-polar channels 00 and 11. The amplitudes of echoes are 1 and 1 for channel 00, 1 and -1 for channel 11. In the case of PySSBWE, the echoes are affected by frequency-domain decays of 0.25 and 0.5 1/Hz. SSBWE methods 1 and 2 (using either the observability or the controlability matrix) are tested. A reference for this spectrum is generated, for a larger frequency bandwidth and noise-free, for comparison. Test strategy The unit test scripts for packages PyBWE, PyPBWE and PySSBWE follow different strategies depending on the function. Modelling functions For the modelling functions PyBWE.burg, PyBWE.mcov, PyPBWE.polar_burg and PySSBWE.statespace_model, we follow this strategy: Check the error messages if the input order for the model is too high or too low. Compare the model's coefficients returned by the function to the expected values. Extrapolation functions For the extrapolation functions PyBWE.ar_extrapolation, PyPBWE.polar_extrapolation and PySSBWE.statespace_extrapolation, we follow this strategy: Check the error messages if the model's coefficients arrays do not have dimensions consistent with the spectrum to extrapolate. Check the error messages if the number of extrapolated samples is not strictly positive. For all extrapolation modes (forward, backward, both), compare the extrapolation returned by the function to the reference (extrapolation factor 3). Echoes properties extraction functions For the echoes properties extraction function PySSBWE.statespace_properties, we follow this strategy: Check the error messages if the model's coefficients arrays do not have dimensions consistent with the input spectrum. Compare the amplitudes of echoes extracted from the State-Space model to the expected values. Compare the targets distances estimated from the echoes time-delays, extracted from the State-Space model, to the expected values. Compare the frequency-domain decays of echoes extracted from the State-Space model to the expected values. Integration tests This library proposes integration tests for the integrated methods PyBWE.BWE, PyPBWE.PBWE and PySSBWE.SSBWE, to ensure they run as expected. These functions are indeed based on the sub-functions tested in the unit tests. These tests can be launched as GitHub actions ( test-script.yml , jobs integrationTestBWE , integrationTestPBWE and integrationTestSSBWE ). The output is printed in the console. Test scenario The unit tests for packages PyBWE, PyPBWE and PySSBWE are performed on synthetic radar data. All 3 are based on a similar scenario: 2 targets in sight of the radar, at distances 1 and 1.1 m, generate echoes in the radar signal of amplitudes 1 and 1. The radar output is a spectrum of 151 frequencies between 1.5 and 3 GHz. The spectrum is corrupted by a white-noise of a low standard deviation 1e-6 (to ensure a certain reproducibility of results). In the case of PyPBWE, 2 signals are generated for 2 co-polar channels 00 and 11. The amplitudes of echoes are 1 and 1 for channel 00, 1 and -1 for channel 11. SSBWE methods 1 and 2 (using either the observability or the controlability matrix) are tested. Test strategy The integration test scripts for functions PyBWE.BWE, PyPBWE.PBWE and PySSBWE.SSBWE follow this strategy: Check if the function runs without failure with different parameters. Check the dimensions, the 1 st and the last value of the time vector returned by the function. Check if the time vector and the radar sounding returned by the function have the same dimension. Check if 2 echoes are detected in the radar sounding returned by the function. Check if the amplitudes (module) of the 2 echoes in the radar sounding returned by the function are 1 and 1. Check if the distances of the 2 targets, estimated from the time-delays of echoes in the radar sounding returned by the function, are 1 and 1.1 m.","title":"Unit and integration tests"},{"location":"unit_integration_tests/#unit-tests","text":"This library proposes unit tests for all unit functions of packages PyBWE, PyPBWE and PySSBWE, to ensure they run independently as expected. These tests can be launched as GitHub actions ( test-script.yml , jobs unitTestBWE , unitTestPBWE and unitTestSSBWE ). The output is printed in the console. The unit test scripts for the PyBWE, PyPBWE and PySSBWE packages in this library can be found at: test/script_unit_test_BWE.py test/script_unit_test_PBWE.py test/script_unit_test_SSBWE.py","title":"Unit tests"},{"location":"unit_integration_tests/#test-scenario","text":"The unit tests for packages PyBWE, PyPBWE and PySSBWE are performed on synthetic radar data. All 3 are based on a similar scenario: 2 targets in sight of the radar, at distances 1 and 1.1 m, generate echoes in the radar signal of amplitudes 1 and 1. The radar output is a spectrum of 151 frequencies between 1.5 and 3 GHz. The spectrum is corrupted by a white-noise of a low standard deviation 1e-6 (to ensure a certain reproducibility of results). In the case of PyPBWE, 2 signals are generated for 2 co-polar channels 00 and 11. The amplitudes of echoes are 1 and 1 for channel 00, 1 and -1 for channel 11. In the case of PySSBWE, the echoes are affected by frequency-domain decays of 0.25 and 0.5 1/Hz. SSBWE methods 1 and 2 (using either the observability or the controlability matrix) are tested. A reference for this spectrum is generated, for a larger frequency bandwidth and noise-free, for comparison.","title":"Test scenario"},{"location":"unit_integration_tests/#test-strategy","text":"The unit test scripts for packages PyBWE, PyPBWE and PySSBWE follow different strategies depending on the function.","title":"Test strategy"},{"location":"unit_integration_tests/#modelling-functions","text":"For the modelling functions PyBWE.burg, PyBWE.mcov, PyPBWE.polar_burg and PySSBWE.statespace_model, we follow this strategy: Check the error messages if the input order for the model is too high or too low. Compare the model's coefficients returned by the function to the expected values.","title":"Modelling functions"},{"location":"unit_integration_tests/#extrapolation-functions","text":"For the extrapolation functions PyBWE.ar_extrapolation, PyPBWE.polar_extrapolation and PySSBWE.statespace_extrapolation, we follow this strategy: Check the error messages if the model's coefficients arrays do not have dimensions consistent with the spectrum to extrapolate. Check the error messages if the number of extrapolated samples is not strictly positive. For all extrapolation modes (forward, backward, both), compare the extrapolation returned by the function to the reference (extrapolation factor 3).","title":"Extrapolation functions"},{"location":"unit_integration_tests/#echoes-properties-extraction-functions","text":"For the echoes properties extraction function PySSBWE.statespace_properties, we follow this strategy: Check the error messages if the model's coefficients arrays do not have dimensions consistent with the input spectrum. Compare the amplitudes of echoes extracted from the State-Space model to the expected values. Compare the targets distances estimated from the echoes time-delays, extracted from the State-Space model, to the expected values. Compare the frequency-domain decays of echoes extracted from the State-Space model to the expected values.","title":"Echoes properties extraction functions"},{"location":"unit_integration_tests/#integration-tests","text":"This library proposes integration tests for the integrated methods PyBWE.BWE, PyPBWE.PBWE and PySSBWE.SSBWE, to ensure they run as expected. These functions are indeed based on the sub-functions tested in the unit tests. These tests can be launched as GitHub actions ( test-script.yml , jobs integrationTestBWE , integrationTestPBWE and integrationTestSSBWE ). The output is printed in the console.","title":"Integration tests"},{"location":"unit_integration_tests/#test-scenario_1","text":"The unit tests for packages PyBWE, PyPBWE and PySSBWE are performed on synthetic radar data. All 3 are based on a similar scenario: 2 targets in sight of the radar, at distances 1 and 1.1 m, generate echoes in the radar signal of amplitudes 1 and 1. The radar output is a spectrum of 151 frequencies between 1.5 and 3 GHz. The spectrum is corrupted by a white-noise of a low standard deviation 1e-6 (to ensure a certain reproducibility of results). In the case of PyPBWE, 2 signals are generated for 2 co-polar channels 00 and 11. The amplitudes of echoes are 1 and 1 for channel 00, 1 and -1 for channel 11. SSBWE methods 1 and 2 (using either the observability or the controlability matrix) are tested.","title":"Test scenario"},{"location":"unit_integration_tests/#test-strategy_1","text":"The integration test scripts for functions PyBWE.BWE, PyPBWE.PBWE and PySSBWE.SSBWE follow this strategy: Check if the function runs without failure with different parameters. Check the dimensions, the 1 st and the last value of the time vector returned by the function. Check if the time vector and the radar sounding returned by the function have the same dimension. Check if 2 echoes are detected in the radar sounding returned by the function. Check if the amplitudes (module) of the 2 echoes in the radar sounding returned by the function are 1 and 1. Check if the distances of the 2 targets, estimated from the time-delays of echoes in the radar sounding returned by the function, are 1 and 1.1 m.","title":"Test strategy"},{"location":"joss/paper/","text":"Summary PyBWE is a Python library containing radar super-resolution methods known as \"Bandwidth Extrapolation\" (BWE). Range resolution enhancement is one of the main challenges in radar signal processing. It is driven by the time resolution of radar soundings, and the speed of electromagnetic waves in the sounded material. Time resolution being limited by the frequency bandwidth of the instrument, the same applies to range resolution: the larger the bandwidth, the more enhanced the resolution. Fast Fourier Transform techniques are efficient and robust for spectral estimation, but their performances in time resolution are limited by the inverse of the bandwidth, and the necessary application of windowing to reduce the impact of side-lobes. For this reason parametric spectral estimation techniques have been introduced [@Kay:1981]. Based on a signal model, assuming deterministic properties of the signal, the output of such techniques yields an enhanced resolution. However, parametric techniques are less robust than classic Fourier transform ones, in particular in the presence of noise or distortions. The Bandwidth Extrapolation technique ( BWE ) is a compromise between a classic Fourier transform and a parametric spectral estimation technique [@Cuomo:1992]. A parametric model is fitted to the measured signal's spectrum, this model is then used to extrapolate this spectrum forward and backward, and the spectrum is eventually Fourier transformed using an IFFT. The extrapolation factor is equal to the resolution enhancement, and can be up to 3 in practical cases. The extrapolation of a radar spectrum is indeed possible, as it can be modelled by a sum of complex sine-waves with different amplitudes, frequencies and phases. Each of these complex sine-waves corresponds to a target echo in time-domain. In practical cases, this deterministic signal is corrupted by various sources of noise, distorsions, and can be dampened by losses in the sounded material. Hence the limitation of a radar spectrum extrapolation. An example of application on a synthetic planetary radar spectrum, inspired by the WISDOM (ExoMars, ESA) planetary radar [@Ciarletti:2017], is shown in \\autoref{fig:example}. In the regular BWE, the signal is modelled by an autoregressive (AR) model, which coefficients are determined with the Burg algorithm. Several improvements to the BWE have been proposed: The Polarimetric BWE ( PBWE ) accounting for the correlation between several polarimetric radar channels with a multi-channel AR model, which coefficients are determined by a multi-channel Burg algorithm [@Suwa:2003] [@Suwa:2007]. The State-Space BWE ( SSBWE ) accounting for noise and distorsions in radar signals with an autoregressive moving-average (ARMA) model, which coefficients are determined by State-Space identification [@Piou:1999]. Also, the BWE can be used to fill a gap between two spectra of multiband radars [@Moore:1997], or for Electromagnetic Interference (EMI) removal [@Piazzo:2019]. This process is known as Bandwidth Interpolation ( BWI ). This library contains 3 packages, each containing a different BWE technique, based on a different signal model: PyBWE: implementing the \"classic\" BWE technique. PyPBWE: implementing the PBWE technique. PySSBWE: implementing the SSBWE technique. Each package contains an integrated solution to directly apply the complete BWE process to a given radar spectrum, as well as all the individual functions for modelling and extrapolation. This library relies on Numpy [@Harris:2020] for the linear algebra, on Scipy [@Virtanen:2020] for matrix operations and data processing functions used in test and examples, on Matplolib [@Hunter:2007] for figure display in examples, and on Pandas [@Pandas:2020] for performance tests data handling. Statement of need If the BWE can be applied to any radar signal, it has been extensively applied to planetary radar sounders in the last decade. Radar sounders unlocked a 3 rd dimension in planetary studies, unveiling the subsurface of the Moon, Mars, Titan and soon Venus and Jupiter's moons. The design of planetary exploration instruments being highly constrained, the resolution performances of radar sounders are not only driven by the scientific objectives of a mission. In this context, the BWE is a powerful tool to get further insights on the subsurface structure and composition from a given radar sounder. Here is a non-exhaustive list of successful BWE applications in planetary science: The 1 st bathymetry of a Titan sea using Cassini (NASA) radar data [@Mastrogiuseppe:2014] The improvement of the stratigraphic analysis of Martian polar ice sheets using the SHARAD (MRO, NASA) radar sounder data, after both BWE and EMI removal by BWI [@Raguso:2018] [@Raguso:2023]. The improvement of the WISDOM (ExoMars, ESA) Ground Penetrating Radar soundings in preparation of the Rosalind Franklin rover mission [@Oudart:2021] The improvement of the MARSIS (Mars Express, ESA) radar sounder resolution by a factor of 6 using both BWE and BWI between different frequency band modes [@Gambacorta:2022] The EMI removal by BWI helped the estimation of attenuations in the Martian subsurface with the RIMFAX (Mars 2020, NASA) Ground Penetrating Radar data [@Eide:2022] However, the planetary science community has few radar experts, and to our knowledge no open-source integrated BWE solutions existed before the release of this library, limiting the planetary radar application of this technique. For this reason, we propose in this library integrated BWE solutions for all planetary scientists, as well as the individual functions for planetary radar experts. In addition, this library could also benefit other radar / sonar applications developed under harsh contraints, impacting the reachable range resolution. Acknowledgments The author would like to thank Val\u00e9rie Ciarletti, Alice Le Gall and Emile Brighi for their helpful comments and suggestions. References","title":"PyBWE: Python tools for Bandwidth Extrapolation of planetary radar signals"},{"location":"joss/paper/#summary","text":"PyBWE is a Python library containing radar super-resolution methods known as \"Bandwidth Extrapolation\" (BWE). Range resolution enhancement is one of the main challenges in radar signal processing. It is driven by the time resolution of radar soundings, and the speed of electromagnetic waves in the sounded material. Time resolution being limited by the frequency bandwidth of the instrument, the same applies to range resolution: the larger the bandwidth, the more enhanced the resolution. Fast Fourier Transform techniques are efficient and robust for spectral estimation, but their performances in time resolution are limited by the inverse of the bandwidth, and the necessary application of windowing to reduce the impact of side-lobes. For this reason parametric spectral estimation techniques have been introduced [@Kay:1981]. Based on a signal model, assuming deterministic properties of the signal, the output of such techniques yields an enhanced resolution. However, parametric techniques are less robust than classic Fourier transform ones, in particular in the presence of noise or distortions. The Bandwidth Extrapolation technique ( BWE ) is a compromise between a classic Fourier transform and a parametric spectral estimation technique [@Cuomo:1992]. A parametric model is fitted to the measured signal's spectrum, this model is then used to extrapolate this spectrum forward and backward, and the spectrum is eventually Fourier transformed using an IFFT. The extrapolation factor is equal to the resolution enhancement, and can be up to 3 in practical cases. The extrapolation of a radar spectrum is indeed possible, as it can be modelled by a sum of complex sine-waves with different amplitudes, frequencies and phases. Each of these complex sine-waves corresponds to a target echo in time-domain. In practical cases, this deterministic signal is corrupted by various sources of noise, distorsions, and can be dampened by losses in the sounded material. Hence the limitation of a radar spectrum extrapolation. An example of application on a synthetic planetary radar spectrum, inspired by the WISDOM (ExoMars, ESA) planetary radar [@Ciarletti:2017], is shown in \\autoref{fig:example}. In the regular BWE, the signal is modelled by an autoregressive (AR) model, which coefficients are determined with the Burg algorithm. Several improvements to the BWE have been proposed: The Polarimetric BWE ( PBWE ) accounting for the correlation between several polarimetric radar channels with a multi-channel AR model, which coefficients are determined by a multi-channel Burg algorithm [@Suwa:2003] [@Suwa:2007]. The State-Space BWE ( SSBWE ) accounting for noise and distorsions in radar signals with an autoregressive moving-average (ARMA) model, which coefficients are determined by State-Space identification [@Piou:1999]. Also, the BWE can be used to fill a gap between two spectra of multiband radars [@Moore:1997], or for Electromagnetic Interference (EMI) removal [@Piazzo:2019]. This process is known as Bandwidth Interpolation ( BWI ). This library contains 3 packages, each containing a different BWE technique, based on a different signal model: PyBWE: implementing the \"classic\" BWE technique. PyPBWE: implementing the PBWE technique. PySSBWE: implementing the SSBWE technique. Each package contains an integrated solution to directly apply the complete BWE process to a given radar spectrum, as well as all the individual functions for modelling and extrapolation. This library relies on Numpy [@Harris:2020] for the linear algebra, on Scipy [@Virtanen:2020] for matrix operations and data processing functions used in test and examples, on Matplolib [@Hunter:2007] for figure display in examples, and on Pandas [@Pandas:2020] for performance tests data handling.","title":"Summary"},{"location":"joss/paper/#statement-of-need","text":"If the BWE can be applied to any radar signal, it has been extensively applied to planetary radar sounders in the last decade. Radar sounders unlocked a 3 rd dimension in planetary studies, unveiling the subsurface of the Moon, Mars, Titan and soon Venus and Jupiter's moons. The design of planetary exploration instruments being highly constrained, the resolution performances of radar sounders are not only driven by the scientific objectives of a mission. In this context, the BWE is a powerful tool to get further insights on the subsurface structure and composition from a given radar sounder. Here is a non-exhaustive list of successful BWE applications in planetary science: The 1 st bathymetry of a Titan sea using Cassini (NASA) radar data [@Mastrogiuseppe:2014] The improvement of the stratigraphic analysis of Martian polar ice sheets using the SHARAD (MRO, NASA) radar sounder data, after both BWE and EMI removal by BWI [@Raguso:2018] [@Raguso:2023]. The improvement of the WISDOM (ExoMars, ESA) Ground Penetrating Radar soundings in preparation of the Rosalind Franklin rover mission [@Oudart:2021] The improvement of the MARSIS (Mars Express, ESA) radar sounder resolution by a factor of 6 using both BWE and BWI between different frequency band modes [@Gambacorta:2022] The EMI removal by BWI helped the estimation of attenuations in the Martian subsurface with the RIMFAX (Mars 2020, NASA) Ground Penetrating Radar data [@Eide:2022] However, the planetary science community has few radar experts, and to our knowledge no open-source integrated BWE solutions existed before the release of this library, limiting the planetary radar application of this technique. For this reason, we propose in this library integrated BWE solutions for all planetary scientists, as well as the individual functions for planetary radar experts. In addition, this library could also benefit other radar / sonar applications developed under harsh contraints, impacting the reachable range resolution.","title":"Statement of need"},{"location":"joss/paper/#acknowledgments","text":"The author would like to thank Val\u00e9rie Ciarletti, Alice Le Gall and Emile Brighi for their helpful comments and suggestions.","title":"Acknowledgments"},{"location":"joss/paper/#references","text":"","title":"References"},{"location":"reference/SUMMARY/","text":"","title":"SUMMARY"}]}